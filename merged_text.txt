############# src\audio.cpp #############

#include "audio.h"
#include "config.h"
#include "network_manager.h"
#include <esp_log.h>

static const char *TAG = "AUDIO";

const i2s_config_t Audio::i2sConfigRx = {
        .mode = (i2s_mode_t) (I2S_MODE_MASTER | I2S_MODE_RX),
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = (i2s_bits_per_sample_t) BITS_PER_SAMPLE,
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = (i2s_comm_format_t) (I2S_COMM_FORMAT_STAND_I2S),
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = DMA_BUF_COUNT,
        .dma_buf_len = DMA_BUF_LEN,
        .use_apll = false,
        .tx_desc_auto_clear = true,
        .fixed_mclk = 0
};

const i2s_pin_config_t Audio::i2sPinConfigRx = {
        .bck_io_num = I2S_PIN_INMP441_SCK,
        .ws_io_num = I2S_PIN_INMP441_WS,
        .data_out_num = I2S_PIN_NO_CHANGE,
        .data_in_num = I2S_PIN_INMP441_SD
};

const i2s_config_t Audio::i2sConfigTx = {
        .mode = (i2s_mode_t) (I2S_MODE_MASTER | I2S_MODE_TX),
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = (i2s_bits_per_sample_t) BITS_PER_SAMPLE,
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = (i2s_comm_format_t) (I2S_COMM_FORMAT_STAND_I2S),
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = DMA_BUF_COUNT,
        .dma_buf_len = DMA_BUF_LEN,
        .use_apll = false
};

const i2s_pin_config_t Audio::i2sPinConfigTx = {
        .bck_io_num = I2S_PIN_BCLK,
        .ws_io_num = I2S_PIN_LRCK,
        .data_out_num = I2S_PIN_DATA,
        .data_in_num = I2S_PIN_NO_CHANGE
};

SemaphoreHandle_t Audio::i2sBufferMutex = nullptr;
uint8_t *Audio::i2sBuffer = nullptr;
size_t Audio::i2sBufferSize = I2S_BUFFER_SIZE;
volatile size_t Audio::i2sBufferHead = 0;
volatile size_t Audio::i2sBufferTail = 0;
TaskHandle_t Audio::i2sReaderTaskHandle = nullptr;
TaskHandle_t Audio::i2sWriterTaskHandle = nullptr;

void Audio::begin() {
    i2sBufferMutex = xSemaphoreCreateMutex();

    // Allocate memory for the I2S buffer dynamically
    i2sBuffer = (uint8_t *) malloc(i2sBufferSize * sizeof(uint8_t));

    if (i2sBuffer == nullptr) {
        ESP_LOGE(TAG, "Error allocating memory for I2S buffer!");
    }

    // Initialize I2S RX
    if (i2s_driver_install(I2S_NUM_1, &i2sConfigRx, 0, nullptr) != ESP_OK) {
        ESP_LOGE(TAG, "Error installing I2S RX driver!");
    }

    i2s_set_pin(I2S_NUM_1, &i2sPinConfigRx);
    i2s_zero_dma_buffer(I2S_NUM_1);

    // Initialize I2S TX
    if (i2s_driver_install(I2S_NUM_0, &i2sConfigTx, 0, nullptr) != ESP_OK) {
        ESP_LOGE(TAG, "Error installing I2S TX driver!");
    }
    i2s_set_pin(I2S_NUM_0, &i2sPinConfigTx);
    i2s_zero_dma_buffer(I2S_NUM_0);

    xTaskCreatePinnedToCore(i2sReaderTask, "I2S Reader Task", 8192, nullptr, 2, &i2sReaderTaskHandle, 1);
    xTaskCreatePinnedToCore(i2sWriterTask, "I2S Writer Task", 8192, nullptr, 3, &i2sWriterTaskHandle, 1);

    vTaskSuspend(i2sReaderTaskHandle); // Initially suspend the reader task
    vTaskSuspend(i2sWriterTaskHandle); // Initially suspend the writer task
}

void Audio::startRecording() {
    vTaskResume(i2sReaderTaskHandle);
    ESP_LOGI(TAG, "Recording started");
}

void Audio::stopRecording() {
    vTaskSuspend(i2sReaderTaskHandle);
    ESP_LOGI(TAG, "Recording stopped");
}

void Audio::startPlayback() {
    vTaskResume(i2sWriterTaskHandle);
    ESP_LOGI(TAG, "Playback started");
}

void Audio::stopPlayback() {
    vTaskSuspend(i2sWriterTaskHandle);
    ESP_LOGI(TAG, "Playback stopped");

    // Clear the I2S DMA buffer
    i2s_zero_dma_buffer(I2S_NUM_0);

    // Clear the buffer when playback stops
    if (xSemaphoreTake(i2sBufferMutex, portMAX_DELAY) == pdTRUE) {
        i2sBufferHead = 0;
        i2sBufferTail = 0;
        xSemaphoreGive(i2sBufferMutex);
    }
}

void Audio::addDataToBuffer(const uint8_t *data, size_t length) {
    if (xSemaphoreTake(i2sBufferMutex, portMAX_DELAY) == pdTRUE) {
        for (size_t i = 0; i < length; i++) {
            i2sBuffer[i2sBufferHead] = data[i];
            i2sBufferHead = (i2sBufferHead + 1) % I2S_BUFFER_SIZE;
            if (i2sBufferHead == i2sBufferTail) // Buffer overflow, discard oldest data
            {
                i2sBufferTail = (i2sBufferTail + 1) % I2S_BUFFER_SIZE;
            }
        }
        xSemaphoreGive(i2sBufferMutex);
    }
}

[[noreturn]] void Audio::i2sReaderTask(void *parameter) {
    size_t bytesRead = 0;

    // Dynamically allocate i2SMicBuffer
    auto *i2SMicBuffer = new uint8_t[DMA_BUF_LEN * 2];
    auto *prependedBuffer = new uint8_t[DMA_BUF_LEN * 2 + 6];

    while (true) {
        i2s_read(I2S_NUM_1, i2SMicBuffer, DMA_BUF_LEN * 2, &bytesRead, portMAX_DELAY); // Read from Microphone
        if (bytesRead > 0) {
            memcpy(prependedBuffer, "AUDIO:", 6);
            memcpy(prependedBuffer + 6, i2SMicBuffer, bytesRead);

            NetworkManager::sendAudioChunk(prependedBuffer, bytesRead + 6);


//            Event event = {EVENT_AUDIO_CHUNK_READ, std::string(reinterpret_cast<char *>(prependedBuffer)),
//                           bytesRead + 6};
//            eventDispatcher->dispatchEvent(event);
        }

    }

    // Free allocated memory
    delete[] i2SMicBuffer;
    delete[] prependedBuffer;
}

[[noreturn]] void Audio::i2sWriterTask(void *parameter) {
    size_t bytesWritten = 0;
    for (;;) {
        if (xSemaphoreTake(i2sBufferMutex, portMAX_DELAY) == pdTRUE) {
            if (i2sBufferTail != i2sBufferHead) {
                size_t bytesToWrite = (i2sBufferTail < i2sBufferHead) ? (i2sBufferHead - i2sBufferTail) : (
                        I2S_BUFFER_SIZE - i2sBufferTail);
                i2s_write(I2S_NUM_0, &i2sBuffer[i2sBufferTail], bytesToWrite, &bytesWritten, portMAX_DELAY);
                i2sBufferTail = (i2sBufferTail + bytesWritten) % I2S_BUFFER_SIZE;
            }
            xSemaphoreGive(i2sBufferMutex);
        }
        vTaskDelay(10);
    }
}

#########################################

############# src\audio.h #############

// audio.h
#ifndef AUDIO_H
#define AUDIO_H

#include <Arduino.h>
#include <driver/i2s.h>
#include "events.h"

class Audio {
public:
    static void begin();

    static void startRecording();

    static void stopRecording();

    static void startPlayback();

    static void stopPlayback();

    static void addDataToBuffer(const uint8_t *data, size_t length);

private:
    [[noreturn]] static void i2sReaderTask(void *parameter);

    [[noreturn]] static void i2sWriterTask(void *parameter);

    static SemaphoreHandle_t i2sBufferMutex;
    static uint8_t *i2sBuffer;
    static size_t i2sBufferSize;
    static volatile size_t i2sBufferHead;
    static volatile size_t i2sBufferTail;
    static TaskHandle_t i2sReaderTaskHandle;
    static TaskHandle_t i2sWriterTaskHandle;

    // I2S configuration
    static const i2s_config_t i2sConfigRx;
    static const i2s_pin_config_t i2sPinConfigRx;
    static const i2s_config_t i2sConfigTx;
    static const i2s_pin_config_t i2sPinConfigTx;
};

#endif // AUDIO_H

#######################################

############# src\config.h #############

#ifndef CONFIG_H
#define CONFIG_H

#include "U8g2lib.h"

// WiFi credentials
#define WIFI_SSID "Netgear Fiber"
#define WIFI_PASSWORD "Mqwmu2fCakcRRmW"

// WebSocket server details
#define WS_SERVER "192.168.8.35"
#define WS_PORT 8765

// I2S configuration
#define I2S_PIN_BCLK 13
#define I2S_PIN_DATA 15
#define I2S_PIN_LRCK 12

#define I2S_PIN_INMP441_SD 5
#define I2S_PIN_INMP441_WS 16
#define I2S_PIN_INMP441_SCK 17

// Audio settings
#define SAMPLE_RATE 44100
#define BITS_PER_SAMPLE 16
#define CHANNELS 1
#define DMA_BUF_COUNT 8
#define DMA_BUF_LEN 1024

// Buffer sizes
#define I2S_BUFFER_SIZE (1024 * 8) // Adjust as needed

// Fingerprint sensor configuration
#define FINGERPRINT_RX 18
#define FINGERPRINT_TX 17

// OLED I2C address
#define OLED_ADDRESS 0x3C

// Define images
static const unsigned char image_notification_bell_bits[]
        U8X8_PROGMEM = {0x88, 0x11, 0xc6, 0x63, 0x22, 0x44, 0x31, 0x88, 0x11, 0x88, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10,
                        0x08,
                        0x10, 0x04, 0x20, 0x04, 0x20, 0x02, 0x40, 0xff, 0xff, 0x60, 0x06, 0xc0, 0x03, 0x00, 0x00};
static const unsigned char image_device_lock_bits[]
        U8X8_PROGMEM = {0xf0, 0x01, 0x08, 0x02, 0xe4, 0x04, 0x12, 0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0xfe, 0x0f, 0x03, 0x18,
                        0xe5,
                        0x14, 0x11, 0x11, 0x11, 0x11, 0xa1, 0x10, 0xa1, 0x10, 0x45, 0x14, 0x03, 0x18, 0xfe, 0x0f};
static const unsigned char image_microphone_bits[]
        U8X8_PROGMEM = {0xc0, 0x01, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03,
                        0xe8,
                        0x0b, 0xc8, 0x09, 0x10, 0x04, 0xe0, 0x03, 0x80, 0x00, 0x80, 0x00, 0xe0, 0x03, 0x00, 0x00};
static const unsigned char image_volume_loud_bits[]
        U8X8_PROGMEM = {0x80, 0x83, 0x00, 0x40, 0x02, 0x01, 0x20, 0x22, 0x02, 0x10, 0x42, 0x04, 0x0f, 0x8a, 0x04, 0x01,
                        0x92,
                        0x08, 0x01, 0x22, 0x09, 0x01, 0x22, 0x09, 0x01, 0x22, 0x09, 0x01, 0x92, 0x08, 0x0f, 0x8a, 0x04,
                        0x10,
                        0x42, 0x04, 0x20, 0x22, 0x02, 0x40, 0x02, 0x01, 0x80, 0x83, 0x00, 0x00, 0x00, 0x00};

// Fingerprint sensor configuration
#define FINGERPRINT_RX_PIN 16
#define FINGERPRINT_TX_PIN 17

#endif // CONFIG_H

########################################

############# src\events.cpp #############

#include "events.h"

void EventDispatcher::registerCallback(EventType type, EventCallback callback) {
    callbacks[type].push_back(callback);
}

void EventDispatcher::dispatchEvent(const Event &event) {
    for (auto &callback: callbacks[event.type]) {
        callback(event);
    }
}

##########################################

############# src\events.h #############

#ifndef EVENTS_H
#define EVENTS_H

#include <functional>
#include <unordered_map>
#include <queue>

enum EventType {
    EVENT_WIFI_CONNECTED,
    EVENT_WIFI_DISCONNECTED,
    EVENT_WEBSOCKET_CONNECTED,
    EVENT_WEBSOCKET_DISCONNECTED,
    EVENT_RECORD_START,
    EVENT_RECORD_STOP,
    EVENT_PLAYBACK_START,
    EVENT_PLAYBACK_STOP,
    EVENT_KEYPAD_PRESS,
    EVENT_FINGERPRINT_MATCH,
    EVENT_FINGERPRINT_NO_MATCH,
    EVENT_AUDIO_DATA_RECEIVED,
    EVENT_AUDIO_CHUNK_READ,
};

struct Event {
    EventType type;
    std::string data;
    size_t dataLength;
};

using EventCallback = std::function<void(const Event &)>;

class EventDispatcher {
public:
    void registerCallback(EventType type, EventCallback callback);

    void dispatchEvent(const Event &event);

private:
    std::unordered_map<EventType, std::vector<EventCallback>> callbacks;
};

#endif // EVENTS_H


########################################

############# src\fingerprint.cpp #############

#include "fingerprint.h"
#include "config.h"
#include "logger.h"

static const char *TAG = "FINGERPRINT";

FingerprintHandler::FingerprintHandler() : fingerprint(Adafruit_Fingerprint(&Serial2)) {
    Serial2.begin(FINGERPRINT_BAUDRATE_57600, SERIAL_8N1, FINGERPRINT_RX, FINGERPRINT_TX);
}

void FingerprintHandler::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    if (fingerprint.verifyPassword()) {
        LOG_I(TAG, "Found fingerprint sensor!");
    } else {
        LOG_E(TAG, "Did not find fingerprint sensor :(");
    }

    fingerprint.getTemplateCount();

    if (fingerprint.templateCount == 0) {
        LOG_E(TAG, "No fingerprint templates found. Please enroll a fingerprint first.");
    } else {
        LOG_I(TAG, "Fingerprint templates found: %d", fingerprint.templateCount);
    }

    xTaskCreate(fingerprintTask, "Fingerprint Task", 4096, this, 1, nullptr);
}

void FingerprintHandler::fingerprintTask(void *parameter) {
    auto *handler = static_cast<FingerprintHandler *>(parameter);

    while (true) {
        uint8_t p = handler->fingerprint.getImage();
        if (p == FINGERPRINT_OK) {
            LOG_I(TAG, "Image taken");
            p = handler->fingerprint.image2Tz();
            if (p == FINGERPRINT_OK) {
                LOG_I(TAG, "Image converted to template");
                p = handler->fingerprint.fingerFastSearch();
                if (p == FINGERPRINT_OK) {
                    LOG_I(TAG, "Finger found!");
                    handler->eventDispatcher->dispatchEvent({EVENT_FINGERPRINT_MATCH, ""});
                } else if (p == FINGERPRINT_NOTFOUND) {
                    LOG_I(TAG, "No match found");
                    handler->eventDispatcher->dispatchEvent({EVENT_FINGERPRINT_NO_MATCH, ""});
                } else {
                    LOG_E(TAG, "Finger search error: %d", p);
                }
            } else {
                LOG_E(TAG, "Image conversion error: %d", p);
            }
        } else {
            LOG_E(TAG, "Image capture error: %d", p);
        }
        vTaskDelay(100);
    }
}



###############################################

############# src\fingerprint.h #############

#ifndef FINGERPRINT_H
#define FINGERPRINT_H

#include "Adafruit_Fingerprint.h"
#include "events.h"

class FingerprintHandler {
public:
    FingerprintHandler();

    void begin(EventDispatcher &dispatcher);

private:
    static void fingerprintTask(void *parameter);

    Adafruit_Fingerprint fingerprint;
    EventDispatcher *eventDispatcher{};
};

#endif // FINGERPRINT_H

#############################################

############# src\logger.h #############

#ifndef LOGGER_H
#define LOGGER_H

#include <Arduino.h>
#include <cstdarg>

enum LogLevel {
    LOG_NONE = 0,   // No logging
    LOG_ERROR,
    LOG_WARN,
    LOG_INFO,
    LOG_DEBUG
};

extern LogLevel currentLogLevel; // Declare as extern

extern void logger(LogLevel level, const char *tag, const char *format, ...); // Declare as extern

// Macros for convenience (similar to esp_log)
#define LOG_E(tag, format, ...) logger(LOG_ERROR, tag, format, ##__VA_ARGS__)
#define LOG_W(tag, format, ...) logger(LOG_WARN,  tag, format, ##__VA_ARGS__)
#define LOG_I(tag, format, ...) logger(LOG_INFO,  tag, format, ##__VA_ARGS__)
#define LOG_D(tag, format, ...) logger(LOG_DEBUG, tag, format, ##__VA_ARGS__)

#endif // LOGGER_H


########################################

############# src\main.cpp #############

#include <Arduino.h>
#include "events.h"
#include "audio.h"
#include "network_manager.h"
#include "ui.h"
#include "fingerprint.h"
#include "logger.h"

#define LOG_BUFFER_SIZE 128

// Define currentLogLevel
LogLevel currentLogLevel = LOG_DEBUG;

// Define the logger function
void logger(LogLevel level, const char *tag, const char *format, ...) {
    if (level > currentLogLevel) return; // Skip if below current log level

    char message[LOG_BUFFER_SIZE];
    va_list args;
    va_start(args, format);
    vsnprintf(message, LOG_BUFFER_SIZE, format, args);
    va_end(args);

    // Formatted output
    Serial.printf("[%s][%s]: %s\n",
                  level == LOG_ERROR ? "ERROR" : (
                          level == LOG_WARN ? "WARN" : (
                                  level == LOG_INFO ? "INFO" : (
                                          level == LOG_DEBUG ? "DEBUG" : "???"))),
                  tag, message);
}

static const char *TAG = "MAIN";

EventDispatcher eventDispatcher;
NetworkManager wifiHandler;
//UI ui;
FingerprintHandler fingerprintHandler;

// Callback function prototypes
void handleRecordStart(const Event &event);

void handleRecordStop(const Event &event);

void handlePlaybackStart(const Event &event);

void handlePlaybackStop(const Event &event);

void handleWebSocketConnected(const Event &event);

void handleAudioDataReceived(const Event &event);

void handleAudioChunkRead(const Event &event);

void handleFingerprintMatch(const Event &event);

void handleFingerprintNoMatch(const Event &event);

void setup() {
    Serial.begin(115200);

    delay(2000);

    Audio::begin();
    wifiHandler.begin(eventDispatcher);
//    ui.begin(eventDispatcher);
    fingerprintHandler.begin(eventDispatcher);

    // Register callback functions with event dispatcher
    eventDispatcher.registerCallback(EVENT_RECORD_START, &handleRecordStart);
    eventDispatcher.registerCallback(EVENT_RECORD_STOP, &handleRecordStop);
    eventDispatcher.registerCallback(EVENT_PLAYBACK_START, &handlePlaybackStart);
    eventDispatcher.registerCallback(EVENT_PLAYBACK_STOP, &handlePlaybackStop);
    eventDispatcher.registerCallback(EVENT_WEBSOCKET_CONNECTED, &handleWebSocketConnected);
    eventDispatcher.registerCallback(EVENT_AUDIO_DATA_RECEIVED, &handleAudioDataReceived);
    eventDispatcher.registerCallback(EVENT_AUDIO_CHUNK_READ, &handleAudioChunkRead);
    eventDispatcher.registerCallback(EVENT_FINGERPRINT_MATCH, &handleFingerprintMatch);
    eventDispatcher.registerCallback(EVENT_FINGERPRINT_NO_MATCH, &handleFingerprintNoMatch);
}

void loop() {
    // No need to implement loop as FreeRTOS tasks are handling the logic
}


void handleRecordStart(const Event &event) {
    Audio::startRecording();
}

void handleRecordStop(const Event &event) {
    Audio::stopRecording();
}

void handlePlaybackStart(const Event &event) {
    Audio::startPlayback();
}

void handlePlaybackStop(const Event &event) {
    Audio::stopPlayback();
}

void handleWebSocketConnected(const Event &event) {
    NetworkManager::sendInitMessage();
}

void handleAudioDataReceived(const Event &event) {
    Audio::addDataToBuffer(reinterpret_cast<const uint8_t *>(event.data.data()), event.dataLength);
}

void handleAudioChunkRead(const Event &event) {
    NetworkManager::sendAudioChunk(reinterpret_cast<const uint8_t *>(event.data.data()), event.dataLength);
}

void handleFingerprintMatch(const Event &event) {
    LOG_I(TAG, "Fingerprint match found!");
    // TODO: Implement
}

void handleFingerprintNoMatch(const Event &event) {
    LOG_I(TAG, "Fingerprint no match found!");
    // TODO: Implement
}


########################################

############# src\network_manager.cpp #############

#include "network_manager.h"
#include "config.h"
#include "audio.h"
#include <ArduinoJson.h>
#include <WiFi.h>
#include "logger.h"

static const char *TAG = "NetworkManager";

EventDispatcher *NetworkManager::eventDispatcher = nullptr;
WebSocketsClient NetworkManager::webSocket;

void NetworkManager::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    int connectionAttempts = 0;
    while (WiFiClass::status() != WL_CONNECTED && connectionAttempts < 10) {
        delay(500);
        Serial.print(".");
        connectionAttempts++;
    }

    if (WiFiClass::status() == WL_CONNECTED) {
        LOG_I(TAG, "Connected to WiFi network");
        eventDispatcher->dispatchEvent({EVENT_WIFI_CONNECTED, ""});
    } else {
        LOG_E(TAG, "Failed to connect to WiFi network");
        eventDispatcher->dispatchEvent({EVENT_WIFI_DISCONNECTED, ""});
        return;
    }

    webSocket.begin(WS_SERVER, WS_PORT);
    webSocket.onEvent(webSocketEvent);

    xTaskCreate([](void *param) {
        while (true) {
            NetworkManager::loop();
            vTaskDelay(10);
        }
    }, "WiFi Task", 4096, this, 2, nullptr);
}


void NetworkManager::loop() {
    webSocket.loop();
}

void NetworkManager::webSocketEvent(WStype_t type, uint8_t *payload, size_t length) {
    StaticJsonDocument<200> doc;

    switch (type) {
        case WStype_DISCONNECTED:
            LOG_I(TAG, "WebSocket disconnected");
            eventDispatcher->dispatchEvent({EVENT_WEBSOCKET_DISCONNECTED, ""});
            // Handle WebSocket disconnection (e.g., reattempt connection)
            break;
        case WStype_CONNECTED:
            LOG_I(TAG, "WebSocket connected");
            eventDispatcher->dispatchEvent({EVENT_WEBSOCKET_CONNECTED, ""});
            break;
        case WStype_TEXT: {

            DeserializationError error = deserializeJson(doc, payload, length);

            if (error) {
                LOG_E(TAG, "Failed to parse JSON: %s", error.c_str());
                return;
            }

            const char *event_type = doc["event_type"];
            LOG_I(TAG, "Received event: %s", event_type);

            if (strcmp(event_type, "start_recording") == 0) {
                eventDispatcher->dispatchEvent({EVENT_RECORD_START, "", 0});
            } else if (strcmp(event_type, "stop_recording") == 0) {
                eventDispatcher->dispatchEvent({EVENT_RECORD_STOP, "", 0});
            } else if (strcmp(event_type, "start_playing") == 0) {
                eventDispatcher->dispatchEvent({EVENT_PLAYBACK_START, "", 0});
            } else if (strcmp(event_type, "stop_playing") == 0) {
                eventDispatcher->dispatchEvent({EVENT_PLAYBACK_STOP, "", 0});
            }
            break;
        }
        case WStype_BIN: {
        }
            Event event = {EVENT_AUDIO_DATA_RECEIVED, std::string(reinterpret_cast<char *>(payload), length), length};
            eventDispatcher->dispatchEvent(event);
            break;
    }
}

void NetworkManager::sendInitMessage() {
    webSocket.sendTXT(R"({"event_type":"init","data":{"device":"esp_s3"}})");
    LOG_D(TAG, "Sent init message");
}

void NetworkManager::sendAudioChunk(const uint8_t *data, size_t len) {
    webSocket.sendBIN(data, len);
    LOG_D(TAG, "Sent audio chunk");
}

###################################################

############# src\network_manager.h #############

#ifndef WIFI_H
#define WIFI_H

#include "WebSocketsClient.h"
#include "events.h"

class NetworkManager {
public:
    void begin(EventDispatcher &dispatcher);

    static void loop();

    static void sendInitMessage();

    static void sendAudioChunk(const uint8_t *data, size_t len);

private:
    static void webSocketEvent(WStype_t type, uint8_t *payload, size_t length);

    static EventDispatcher *eventDispatcher;
    static WebSocketsClient webSocket;

};

#endif // WIFI_H

#################################################

############# src\ui.cpp #############

#include "ui.h"
#include "config.h"
#include <Keypad.h>
#include <Arduino.h>

// Keypad configuration
// Define keypad size
const byte rows = 4; // Four rows
const byte cols = 3; // Three columns

// Define the key map
char keys[rows][cols] = {
        {'1', '2', '3',},
        {'4', '5', '6',},
        {'7', '8', '9',},
        {'*', '0', '#',}
};

// Connect keypad rows and columns to Arduino pins
byte rowPins[rows] = {12, 14, 27, 26};
byte colPins[cols] = {2, 0, 4};

UI::UI() : keypad(Keypad(makeKeymap(keys), rowPins, colPins, rows, cols)),
           u8g2(U8G2_SSD1306_128X64_NONAME_F_HW_I2C(U8G2_R0, /* reset=*/U8X8_PIN_NONE)) {}

void UI::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    u8g2.begin();
    displayMenu();

    keypad.setDebounceTime(50); // Set debounce time (optional)

    xTaskCreate(loopTask, "UI Task", 4096, this, 1, nullptr);
}


void UI::loopTask(void *parameter) {
    while (true) {
        ((UI *) parameter)->loop();
        vTaskDelay(10);
    }
}

void UI::loop() {
    char key = keypad.getKey();
    if (key) {
        if (enteringPassword) {
            if (key >= '0' && key <= '9') {
                if (passwordIndex < 4) {
                    enteredPassword[passwordIndex++] = key;
                    displayMenu();
                }
            } else if (key == '*') {
                // Clear entered password
                passwordIndex = 0;
                enteredPassword[0] = '\0';
                displayMenu();
            } else if (key == '#') {
                // Exit password entry mode
                enteringPassword = false;
                passwordIndex = 0;
                enteredPassword[0] = '\0';
                displayMenu();
            }
        } else {
            switch (key) {
                case '2': // Up
                    currentMenuItem = (currentMenuItem - 1 + 4) % 4;
                    notificationDisplayed = false;
                    displayMenu();
                    break;
                case '8': // Down
                    currentMenuItem = (currentMenuItem + 1) % 4;
                    notificationDisplayed = false;
                    displayMenu();
                    break;
                case '5': // Select
                    if (currentMenuItem == 0) {
                        notificationDisplayed = true;
                    } else if (currentMenuItem == 1) {
                        enteringPassword = true;
                    }
                    displayMenu();
                    break;
            }
        }
    }
}

void UI::displayMenu() {
    u8g2.clearBuffer();

    if (notificationDisplayed && currentMenuItem == 0) {
        u8g2.setFont(u8g2_font_profont17_tr);
        u8g2.drawStr(15, 32, "OWNER HAS BEEN");
        u8g2.drawStr(35, 47, "NOTIFIED");
    } else if (enteringPassword && currentMenuItem == 1) {
        u8g2.setFont(u8g2_font_profont17_tr);
        u8g2.drawStr(35, 47, "ENTER PASSWORD: ");
        u8g2.drawStr(110, 47, enteredPassword);
    } else {
        switch (currentMenuItem) {
            case 0:
                u8g2.setFont(u8g2_font_profont17_tr);
                u8g2.drawStr(33, 25, "NOTIFY");
                u8g2.drawStr(34, 40, "OWNER");
                u8g2.drawLine(120, 8, 120, 54);
                u8g2.drawXBMP(7, 19, 16, 16, image_notification_bell_bits);
                u8g2.drawEllipse(120, 12, 1, 3);
                break;
            case 1:
                u8g2.drawXBMP(5, 18, 13, 16, image_device_lock_bits);
                u8g2.setFont(u8g2_font_profont17_tr);
                u8g2.drawStr(31, 26, "ENTER");
                u8g2.drawStr(30, 41, "PASSWORD");
                u8g2.drawLine(120, 8, 120, 54);
                u8g2.drawEllipse(120, 21, 1, 3);
                break;
            case 2:
                u8g2.setFont(u8g2_font_profont17_tr);
                u8g2.drawStr(33, 25, "RECORD");
                u8g2.drawStr(34, 40, "AUDIO");
                u8g2.drawLine(120, 8, 120, 54);
                u8g2.drawXBMP(9, 18, 15, 16, image_microphone_bits);
                u8g2.drawEllipse(120, 34, 1, 3);
                break;
            case 3:
                u8g2.setFont(u8g2_font_profont17_tr);
                u8g2.drawStr(33, 20, "PLAY");
                u8g2.drawStr(31, 36, "RECEIVED");
                u8g2.drawLine(120, 8, 120, 54);
                u8g2.drawEllipse(120, 48, 1, 3);
                u8g2.drawXBMP(6, 20, 20, 16, image_volume_loud_bits);
                u8g2.drawStr(31, 52, "AUDIO");
                break;
        }
    }

    u8g2.sendBuffer();
}

void UI::keypadEvent() {
    // This function is required by the Keypad library but is unused in this context.
}



######################################

############# src\ui.h #############

#ifndef UI_H
#define UI_H

#include "U8g2lib.h"
#include "Keypad.h"
#include "events.h"


class UI {
public:
    UI();

    void begin(EventDispatcher &dispatcher);

    void loop();

private:
    void displayMenu();

    static void loopTask(void *parameter);

    static void keypadEvent();

    U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2;
    Keypad keypad;
    EventDispatcher *eventDispatcher{};

    const char *menuItems[4] = {"NOTIFY OWNER", "ENTER PASSWORD", "RECORD AUDIO", "PLAY RECEIVED AUDIO"};
    int currentMenuItem = 0;
    bool notificationDisplayed = false;
    bool enteringPassword = false;
    char enteredPassword[5] = {0}; // Initialize with null terminator
    int passwordIndex = 0;
};

#endif // UI_H

####################################


############# include\audio.h #############

// audio.h
#ifndef AUDIO_H
#define AUDIO_H

#include <Arduino.h>
#include <driver/i2s.h>
#include "events.h"

class Audio {
public:
    static void begin();

    static void startRecording();

    static void stopRecording();

    static void startPlayback();

    static void stopPlayback();

    static void addDataToBuffer(const uint8_t *data, size_t length);

private:
    [[noreturn]] static void i2sReaderTask(void *parameter);

    [[noreturn]] static void i2sWriterTask(void *parameter);

    static SemaphoreHandle_t i2sBufferMutex;
    static uint8_t *i2sBuffer;
    static size_t i2sBufferSize;
    static volatile size_t i2sBufferHead;
    static volatile size_t i2sBufferTail;
    static TaskHandle_t i2sReaderTaskHandle;
    static TaskHandle_t i2sWriterTaskHandle;

    // I2S configuration
    static const i2s_config_t i2sConfigRx;
    static const i2s_pin_config_t i2sPinConfigRx;
    static const i2s_config_t i2sConfigTx;
    static const i2s_pin_config_t i2sPinConfigTx;
};

#endif // AUDIO_H

###########################################

############# include\config.h #############

#ifndef CONFIG_H
#define CONFIG_H

#include "U8g2lib.h"

// WiFi credentials
#define WIFI_SSID "Netgear Fiber"
#define WIFI_PASSWORD "Mqwmu2fCakcRRmW"

// WebSocket server details
#define WS_SERVER "192.168.8.35"
#define WS_PORT 8765

// L298N motor driver configuration
#define MOTOR_PIN1 26
#define MOTOR_PIN2 27
#define MOTOR_ENABLE 14

// PIR sensor configuration
#define PIR_PIN 25

// Break beam sensor configuration
#define BREAK_BEAM_PIN 33

// LED strip configuration
#define LED_STRIP_PIN 32


// I2S configuration
#define I2S_PIN_BCLK 13
#define I2S_PIN_DATA 15
#define I2S_PIN_LRCK 12

#define I2S_PIN_INMP441_SD 5
#define I2S_PIN_INMP441_WS 11
#define I2S_PIN_INMP441_SCK 12

// Audio settings
#define SAMPLE_RATE 44100
#define BITS_PER_SAMPLE 16
#define CHANNELS 1
#define DMA_BUF_COUNT 8
#define DMA_BUF_LEN 1024

// Buffer sizes
#define I2S_BUFFER_SIZE (1024 * 8) // Adjust as needed

// Fingerprint sensor configuration
#define FINGERPRINT_TX 17
#define FINGERPRINT_RX 18

// OLED I2C address
#define OLED_ADDRESS 0x3C

// Define images
static const unsigned char image_notification_bell_bits[]
        U8X8_PROGMEM = {0x88, 0x11, 0xc6, 0x63, 0x22, 0x44, 0x31, 0x88, 0x11, 0x88, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10,
                        0x08,
                        0x10, 0x04, 0x20, 0x04, 0x20, 0x02, 0x40, 0xff, 0xff, 0x60, 0x06, 0xc0, 0x03, 0x00, 0x00};
static const unsigned char image_device_lock_bits[]
        U8X8_PROGMEM = {0xf0, 0x01, 0x08, 0x02, 0xe4, 0x04, 0x12, 0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0xfe, 0x0f, 0x03, 0x18,
                        0xe5,
                        0x14, 0x11, 0x11, 0x11, 0x11, 0xa1, 0x10, 0xa1, 0x10, 0x45, 0x14, 0x03, 0x18, 0xfe, 0x0f};
static const unsigned char image_microphone_bits[]
        U8X8_PROGMEM = {0xc0, 0x01, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03,
                        0xe8,
                        0x0b, 0xc8, 0x09, 0x10, 0x04, 0xe0, 0x03, 0x80, 0x00, 0x80, 0x00, 0xe0, 0x03, 0x00, 0x00};
static const unsigned char image_volume_loud_bits[]
        U8X8_PROGMEM = {0x80, 0x83, 0x00, 0x40, 0x02, 0x01, 0x20, 0x22, 0x02, 0x10, 0x42, 0x04, 0x0f, 0x8a, 0x04, 0x01,
                        0x92,
                        0x08, 0x01, 0x22, 0x09, 0x01, 0x22, 0x09, 0x01, 0x22, 0x09, 0x01, 0x92, 0x08, 0x0f, 0x8a, 0x04,
                        0x10,
                        0x42, 0x04, 0x20, 0x22, 0x02, 0x40, 0x02, 0x01, 0x80, 0x83, 0x00, 0x00, 0x00, 0x00};

#endif // CONFIG_H

############################################

############# include\esp_now_manager.h #############

#ifndef ESP_NOW_MANAGER_H
#define ESP_NOW_MANAGER_H

#include <Arduino.h>
#include <esp_now.h>
#include "events.h"

#define ESPNOW_CHANNEL 1

class ESPNow {
public:
    static void begin(EventDispatcher &dispatcher);

    static void sendCommand(const char *command);

private:
    static void onDataReceived(const uint8_t *mac, const uint8_t *data, int len);

    static void onDataSent(const uint8_t *mac_addr, esp_now_send_status_t status);

    static EventDispatcher *eventDispatcher;
    static esp_now_peer_info_t peerInfo;
    static const uint8_t broadcastAddress[];
};

#endif //ESP_NOW_MANAGER_H


#####################################################

############# include\events.h #############

#ifndef EVENTS_H
#define EVENTS_H

#include <functional>
#include <unordered_map>
#include <queue>

enum EventType {
    WIFI_CONNECTED,
    WIFI_DISCONNECTED,
    WEBSOCKET_CONNECTED,
    WEBSOCKET_DISCONNECTED,
    RECORD_START,
    RECORD_STOP,
    PLAYBACK_START,
    PLAYBACK_STOP,
    KEYPAD_PRESS,
    FINGERPRINT_MATCH,
    FINGERPRINT_NO_MATCH,
    AUDIO_DATA_RECEIVED,
    AUDIO_CHUNK_READ,
    ESPNOW_DATA_RECEIVED,
    SEND_CAPTURE_IMAGE_COMMAND,
    MOTION_DETECTED,
    BREAK_BEAM_TRIGGERED,
    CHANGE_STATE
};

struct Event {
    EventType type;
    std::string data;
    size_t dataLength;
};

using EventCallback = std::function<void(const Event &)>;

class EventDispatcher {
public:
    void registerCallback(EventType type, EventCallback callback);

    void dispatchEvent(const Event &event);

private:
    std::unordered_map<EventType, std::vector<EventCallback>> callbacks;
};

#endif // EVENTS_H

############################################

############# include\fingerprint.h #############

#ifndef FINGERPRINT_H
#define FINGERPRINT_H

#include "Adafruit_Fingerprint.h"
#include "events.h"

class FingerprintHandler {
public:
    FingerprintHandler(const HardwareSerial &serial);

    void begin(EventDispatcher &dispatcher);

private:
    static void fingerprintTask(void *parameter);

    HardwareSerial mySerial;
    Adafruit_Fingerprint fingerprint;
    EventDispatcher *eventDispatcher{};
};

#endif // FINGERPRINT_H

#################################################

############# include\gate_control.h #############

#ifndef GATE_CONTROL_H
#define GATE_CONTROL_H

#include <Arduino.h>
#include "events.h"

class GateControl {
public:
    GateControl(int motorPin1, int motorPin2, int enablePin);

    void begin(EventDispatcher &dispatcher);

    void openGate();

    void closeGate();

    bool isGateMoving() const;

    bool isGateOpen() const;


private:
    static void gateControlTask(void *parameter);


    int _motorPin1;
    int _motorPin2;
    int _enablePin;

    unsigned long _movementStartTime = 0;
    bool _isMoving = false;
    static volatile bool _isGateOpen;

    static EventDispatcher *eventDispatcher;


};

#endif // GATE_CONTROL_H


##################################################

############# include\led_control.h #############

#ifndef LED_CONTROL_H
#define LED_CONTROL_H

#include <Arduino.h>
#include "events.h"

class LEDControl {
public:
    LEDControl(int pin);

    void begin(EventDispatcher &dispatcher);

    void turnOn();

    void turnOff();

private:
    int _pin;
    static EventDispatcher *eventDispatcher;
};

#endif // LED_CONTROL_H

#################################################

############# include\logger.h #############

#ifndef LOGGER_H
#define LOGGER_H

#include <Arduino.h>
#include <cstdarg>

enum LogLevel {
    LOG_NONE = 0,   // No logging
    LOG_ERROR,
    LOG_WARN,
    LOG_INFO,
    LOG_DEBUG
};

extern LogLevel currentLogLevel; // Declare as extern

extern void logger(LogLevel level, const char *tag, const char *format, ...); // Declare as extern

// Macros for convenience (similar to esp_log)
#define LOG_E(tag, format, ...) logger(LOG_ERROR, tag, format, ##__VA_ARGS__)
#define LOG_W(tag, format, ...) logger(LOG_WARN,  tag, format, ##__VA_ARGS__)
#define LOG_I(tag, format, ...) logger(LOG_INFO,  tag, format, ##__VA_ARGS__)
#define LOG_D(tag, format, ...) logger(LOG_DEBUG, tag, format, ##__VA_ARGS__)

#endif // LOGGER_H


############################################

############# include\network_manager.h #############

#ifndef WIFI_H
#define WIFI_H

#include "WebSocketsClient.h"
#include "events.h"
#include "ArduinoJson.h"

class NetworkManager {
public:
    void begin(EventDispatcher &dispatcher);

    static void loop();

    static void sendInitMessage();

    static void sendAudioChunk(const uint8_t *data, size_t len);

    static void sendEvent(const char *eventType, const JsonObject &data);

private:
    static void webSocketEvent(WStype_t type, uint8_t *payload, size_t length);

    static EventDispatcher *eventDispatcher;
    static WebSocketsClient webSocket;

};

#endif // WIFI_H

#####################################################

############# include\sensors.h #############

#ifndef SENSORS_H
#define SENSORS_H

#include <Arduino.h>
#include "events.h"

class PIRSensor {
public:
    PIRSensor(int pin);
    void begin(EventDispatcher &dispatcher);

private:
    static void pirTask(void *parameter);
    int _pin;
    static EventDispatcher *eventDispatcher;
    static volatile bool cooldownActive;
};

class BreakBeamSensor {
public:
    BreakBeamSensor(int pin);
    void begin(EventDispatcher &dispatcher);

private:
    static void breakBeamTask(void *parameter);
    int _pin;
    static EventDispatcher *eventDispatcher;
};

#endif // SENSORS_H

#############################################

########################################


############# src\events.cpp #############

#include "events.h"

void EventDispatcher::registerCallback(EventType type, EventCallback callback) {
    callbacks[type].push_back(callback);
}

void EventDispatcher::dispatchEvent(const Event &event) {
    for (auto &callback: callbacks[event.type]) {
        callback(event);
    }
}

##########################################

############# src\fingerprint.cpp #############

#include "fingerprint.h"
#include "config.h"
#include "logger.h"

static const char *TAG = "FINGERPRINT";

FingerprintHandler::FingerprintHandler(const HardwareSerial &serial) : mySerial(serial), fingerprint(&mySerial) {
    mySerial.begin(57600, SERIAL_8N1, FINGERPRINT_RX, FINGERPRINT_TX);
    fingerprint.begin(57600);
}

void FingerprintHandler::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;


    if (fingerprint.verifyPassword()) {
        LOG_I(TAG, "Found fingerprint sensor!");
    } else {
        LOG_E(TAG, "Did not find fingerprint sensor :(");
    }

    fingerprint.getTemplateCount();

    if (fingerprint.templateCount == 0) {
        LOG_E(TAG, "No fingerprint templates found. Please enroll a fingerprint first.");
    } else {
        LOG_I(TAG, "Fingerprint templates found: %d", fingerprint.templateCount);
    }

    xTaskCreate(fingerprintTask, "Fingerprint Task", 4096, this, 1, nullptr);
}

void FingerprintHandler::fingerprintTask(void *parameter) {
    auto *handler = static_cast<FingerprintHandler *>(parameter);

    while (true) {
        uint8_t p = handler->fingerprint.getImage();
        if (p == FINGERPRINT_OK) {
            LOG_I(TAG, "Image taken");
            p = handler->fingerprint.image2Tz();
            if (p == FINGERPRINT_OK) {
                LOG_I(TAG, "Image converted to template");
                p = handler->fingerprint.fingerFastSearch();
                if (p == FINGERPRINT_OK) {
                    LOG_I(TAG, "Finger found!");
                    handler->eventDispatcher->dispatchEvent({FINGERPRINT_MATCH, ""});
                } else if (p == FINGERPRINT_NOTFOUND) {
                    LOG_I(TAG, "No match found");
                    handler->eventDispatcher->dispatchEvent({FINGERPRINT_NO_MATCH, ""});
                } else {
                    LOG_E(TAG, "Finger search error: %d", p);
                }
            } else {
//                LOG_E(TAG, "Image conversion error: %d", p);
                continue;
            }
        } else {
//            LOG_E(TAG, "Image capture error: %d", p);
            continue;
        }
        vTaskDelay(1000);
    }
}






###############################################

############# src\gate_control.cpp #############

#include "gate_control.h"
#include "logger.h"

static const char *TAG = "GATE_CONTROL";

EventDispatcher *GateControl::eventDispatcher = nullptr;

GateControl::GateControl(int motorPin1, int motorPin2, int enablePin)
        : _motorPin1(motorPin1), _motorPin2(motorPin2), _enablePin(enablePin) {
}

void GateControl::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    pinMode(_motorPin1, OUTPUT);
    pinMode(_motorPin2, OUTPUT);
    pinMode(_enablePin, OUTPUT);

    xTaskCreate(gateControlTask, "Gate Control Task", 4096, this, 1, nullptr);

    LOG_I(TAG, "Gate control initialized");
}

void GateControl::openGate() {
    // Check if the gate is already open or in motion
    if (isGateOpen() || isGateMoving()) {
        LOG_I(TAG, "Gate is already open or in motion.");
        return;
    } else {
        digitalWrite(_motorPin1, HIGH);
        digitalWrite(_motorPin2, LOW);
        digitalWrite(_enablePin, HIGH);
        _movementStartTime = millis();
        _isMoving = true;
        LOG_I(TAG, "Gate opening started...");
    }
}

void GateControl::closeGate() {
    // Check if the gate is already closed or in motion
    if (!isGateOpen() || isGateMoving()) {
        LOG_I(TAG, "Gate is already closed or in motion.");
        return;
    } else {
        digitalWrite(_motorPin1, LOW);
        digitalWrite(_motorPin2, HIGH);
        digitalWrite(_enablePin, HIGH);
        _movementStartTime = millis();
        _isMoving = true;
        LOG_I(TAG, "Gate closing started...");
    }

}

bool GateControl::isGateMoving() const {
    return _isMoving;
}

bool GateControl::isGateOpen() const {
    return _isGateOpen;
}


void GateControl::gateControlTask(void *parameter) {
    auto *gateControl = static_cast<GateControl *>(parameter);

    while (true) {
        if (gateControl->isGateMoving() && millis() - gateControl->_movementStartTime > 7000) {
            // Stop the motor
            digitalWrite(gateControl->_enablePin, LOW);
            gateControl->_isMoving = false;

            if (gateControl->isGateOpen()) {
                // Gate is open
                _isGateOpen = true;
            } else {
                // Gate is closed
                _isGateOpen = false;

            }
        }

        vTaskDelay(pdMS_TO_TICKS(100)); // Check every 100ms
    }
}


############# src\main.cpp #############

#include <Arduino.h>
#include "events.h"
#include "audio.h"
#include "network_manager.h"
#include "ui.h"
#include "fingerprint.h"
#include "logger.h"
#include "esp_now_manager.h"
#include "gate_control.h"
#include "sensors.h"
#include "led_control.h"
#include "config.h"

#define LOG_BUFFER_SIZE 128

// Define currentLogLevel
LogLevel currentLogLevel = LOG_DEBUG;

// Define the logger function
void logger(LogLevel level, const char *tag, const char *format, ...) {
    if (level > currentLogLevel) return; // Skip if below current log level

    char message[LOG_BUFFER_SIZE];
    va_list args;
    va_start(args, format);
    vsnprintf(message, LOG_BUFFER_SIZE, format, args);
    va_end(args);

    // Formatted output
    Serial.printf("[%s][%s]: %s\n",
                  level == LOG_ERROR ? "ERROR" : (
                          level == LOG_WARN ? "WARN" : (
                                  level == LOG_INFO ? "INFO" : (
                                          level == LOG_DEBUG ? "DEBUG" : "???"))),
                  tag, message);
}

static const char *TAG = "MAIN";

EventDispatcher eventDispatcher;
NetworkManager wifiHandler;
//UI ui;
HardwareSerial fingerprintSerial(1);
FingerprintHandler fingerprintHandler(fingerprintSerial);
GateControl gateControl(MOTOR_PIN1, MOTOR_PIN2, MOTOR_ENABLE);
PIRSensor pirSensor(PIR_PIN);
BreakBeamSensor breakBeamSensor(BREAK_BEAM_PIN);
LEDControl ledControl(LED_STRIP_PIN);

// Callback function prototypes
void handleRecordStart(const Event &event);

void handleRecordStop(const Event &event);

void handlePlaybackStart(const Event &event);

void handlePlaybackStop(const Event &event);

void handleWebSocketConnected(const Event &event);

void handleAudioDataReceived(const Event &event);

void handleAudioChunkRead(const Event &event);

void handleFingerprintMatch(const Event &event);

void handleFingerprintNoMatch(const Event &event);

void handleSendCaptureImageCommand(const Event &event);

void setup() {
    Serial.begin(115200);

    Audio::begin();
    wifiHandler.begin(eventDispatcher);
//    ui.begin(eventDispatcher);
    fingerprintHandler.begin(eventDispatcher);

    ESPNow::begin(eventDispatcher);

    // Register callback functions with event dispatcher
    eventDispatcher.registerCallback(RECORD_START, &handleRecordStart);
    eventDispatcher.registerCallback(RECORD_STOP, &handleRecordStop);
    eventDispatcher.registerCallback(PLAYBACK_START, &handlePlaybackStart);
    eventDispatcher.registerCallback(PLAYBACK_STOP, &handlePlaybackStop);
    eventDispatcher.registerCallback(WEBSOCKET_CONNECTED, &handleWebSocketConnected);
    eventDispatcher.registerCallback(AUDIO_DATA_RECEIVED, &handleAudioDataReceived);
    eventDispatcher.registerCallback(AUDIO_CHUNK_READ, &handleAudioChunkRead);
    eventDispatcher.registerCallback(FINGERPRINT_MATCH, &handleFingerprintMatch);
    eventDispatcher.registerCallback(FINGERPRINT_NO_MATCH, &handleFingerprintNoMatch);

    eventDispatcher.registerCallback(SEND_CAPTURE_IMAGE_COMMAND, handleSendCaptureImageCommand);
}

void loop() {
    // No need to implement loop as FreeRTOS tasks are handling the logic
}


void handleRecordStart(const Event &event) {
    Audio::startRecording();
}

void handleRecordStop(const Event &event) {
    Audio::stopRecording();
}

void handlePlaybackStart(const Event &event) {
    Audio::startPlayback();
}

void handlePlaybackStop(const Event &event) {
    Audio::stopPlayback();
}

void handleWebSocketConnected(const Event &event) {
    NetworkManager::sendInitMessage();
}

void handleAudioDataReceived(const Event &event) {
    Audio::addDataToBuffer(reinterpret_cast<const uint8_t *>(event.data.data()), event.dataLength);
}

void handleAudioChunkRead(const Event &event) {
    NetworkManager::sendAudioChunk(reinterpret_cast<const uint8_t *>(event.data.data()), event.dataLength);
}

void handleFingerprintMatch(const Event &event) {
    LOG_I(TAG, "Fingerprint match found!");
    // TODO: Implement
}

void handleFingerprintNoMatch(const Event &event) {
    LOG_I(TAG, "Fingerprint no match found!");
    // TODO: Implement
}

void handleSendCaptureImageCommand(const Event &event) {
    ESPNow::sendCommand("capture_image");
}

########################################
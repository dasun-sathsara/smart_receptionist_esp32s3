############# include\audio.h #############

#ifndef AUDIO_H
#define AUDIO_H

#include <Arduino.h>
#include <driver/i2s.h>
#include "freertos/ringbuf.h"
#include "events.h"

class Audio {
public:
    static void begin(EventDispatcher &dispatcher);

    static void startRecording();

    static void stopRecording();

    static void startPlayback();

    static void stopPlayback();

    static void addPrefetchData(const uint8_t *data, size_t length);

    static void startPrefetch();

    static void stopPrefetch();

private:
    static void audioTask(void *parameter);

    static EventDispatcher *eventDispatcher;

    // I2S configuration
    static const i2s_config_t i2sConfigRx;
    static const i2s_pin_config_t i2sPinConfigRx;
    static const i2s_config_t i2sConfigTx;
    static const i2s_pin_config_t i2sPinConfigTx;

    static volatile bool isRecording;
    static volatile bool isPlaying;
    static volatile bool isPrefetching;

    static uint8_t *audioBuffer;
    static size_t audioBufferIndex;
    static size_t audioBufferSize;

    static void clearAudioBuffer();

    static void sendAudioData();

    static size_t min(size_t a, size_t b);
};

#endif // AUDIO_H

###########################################

############# include\config.h #############

#ifndef CONFIG_H
#define CONFIG_H

#include <Arduino.h>
#include "U8g2lib.h"

// WiFi credentials
#define WIFI_SSID "Xperia 1 II"
#define WIFI_PASSWORD "12345678"

// WebSocket server details
#define WS_SERVER "192.168.17.218"
#define WS_PORT 8765

// L298N motor driver configuration
#define MOTOR_PIN1 39
#define MOTOR_PIN2 38
#define MOTOR_ENABLE 47

// Audio buffer size
#define AUDIO_BUFFER_SIZE (6 * 1024 * 1024) // 6MB buffer (Allocated in PSRAM)

// PIR sensor configuration
#define PIR_PIN 42

// Break beam sensor configuration
#define BREAK_BEAM_PIN 41

// LED strip configuration
#define LED_STRIP_PIN 40

#define RGB_LED_PIN 48
#define NUM_LEDS 1

// Door Sensor configuration
#define REED_SWITCH_PIN 14

// I2S configuration for INMP441 microphone
#define I2S_MIC_SERIAL_CLOCK 3
#define I2S_MIC_LEFT_RIGHT_CLOCK 9
#define I2S_MIC_SERIAL_DATA 10

// I2S configuration for MAX98357A amplifier
#define I2S_SPEAKER_SERIAL_CLOCK 11
#define I2S_SPEAKER_LEFT_RIGHT_CLOCK 12
#define I2S_SPEAKER_SERIAL_DATA 13

// Audio settings
#define SAMPLE_RATE 16000
#define BITS_PER_SAMPLE 16

// DMA buffer settings
#define DMA_BUF_COUNT 8
#define DMA_BUF_LEN 1024

// Fingerprint sensor configuration
#define FINGERPRINT_TX 1
#define FINGERPRINT_RX 2

// OLED I2C address
#define SDA_PIN 18
#define SCL_PIN 8
#define I2C_ADDRESS 0x3C

// Keypad configuration
#define ROW1 4
#define ROW2 5
#define ROW3 6
#define ROW4 7
#define COL1 15
#define COL2 16
#define COL3 17

// Gate control configuration
#define GATE_PWM_FREQ 30000
#define GATE_PWM_CHANNEL 0
#define GATE_PWM_RESOLUTION 8
#define GATE_DUTY_CYCLE 200
#define GATE_OPERATION_TIME 5000 // 5.5 seconds in milliseconds
#endif // CONFIG_H

############################################

############# include\esp_now_manager.h #############

#ifndef ESP_NOW_MANAGER_H
#define ESP_NOW_MANAGER_H

#include <Arduino.h>
#include <esp_now.h>
#include "events.h"

#define ESPNOW_CHANNEL 1

class ESPNow {
public:
    static void begin(EventDispatcher &dispatcher);

    static void sendCommand(const char *command);

private:
    static void onDataReceived(const uint8_t *mac, const uint8_t *data, int len);

    static void onDataSent(const uint8_t *mac_addr, esp_now_send_status_t status);

    static EventDispatcher *eventDispatcher;
    static esp_now_peer_info_t peerInfo;
    static const uint8_t broadcastAddress[];
};

#endif //ESP_NOW_MANAGER_H


#####################################################

############# include\events.h #############

#ifndef EVENTS_H
#define EVENTS_H

#include <functional>
#include <vector>
#include <bitset>
#include <cstdint>
#include <string>

constexpr size_t MAX_EVENTS = 128;

using EventType = uint8_t;

struct Event {
    EventType type;
    std::string data;
    size_t dataLength;

    Event(EventType t, const std::string &d = "", size_t s = 0) : type(t), data(d), dataLength(s == 0 ? d.size() : s) {}
};

using EventCallback = std::function<void(const Event &)>;

class EventDispatcher {
public:
    void registerCallback(EventType type, EventCallback callback);

    void dispatchEvent(const Event &event);

private:
    struct CallbackEntry {
        EventType type;
        EventCallback callback;
    };

    std::vector<CallbackEntry> callbacks;
    std::bitset<MAX_EVENTS> registeredEvents;
};

enum Events : EventType {
    WS_CONNECTED = 0,
    CMD_TG_AUDIO,
    CMD_ESP_AUDIO,
    FINGERPRINT_MATCHED,
    FINGERPRINT_NO_MATCH,
    AUDIO_DATA_RECEIVED,
    ESPNOW_DATA_RECEIVED,
    MOTION_DETECTED,
    CMD_CHANGE_STATE,
    INACTIVITY_DETECTED,
    GATE_OPENED,
    GATE_CLOSED,
    LED_TURNED_ON,
    PERSON_DETECTED,
    LED_TURNED_OFF,
    PASSWORD_VALID,
    PASSWORD_INVALID,
    CMD_GRANT_ACCESS,
    CMD_DENY_ACCESS,
    AUDIO_DATA_READY,
    RECORDING_SENT,
    NO_AUDIO_DATA,
    VISITOR_ENTERED,
    CMD_ENROLL_FINGERPRINT,
    PLACE_FINGER,
    PLACE_FINGER_AGAIN,
    REMOVE_FINGER,
    FINGERPRINT_ENROLLED,
    FINGERPRINT_ENROLL_FAILED,
    MOTION_ENABLE,
    DISABLE_STATUS_LED,
};

#endif // EVENTS_H

############################################

############# include\event_handler.h #############

#ifndef EVENT_HANDLER_H
#define EVENT_HANDLER_H

#include "events.h"
#include "audio.h"
#include "network_manager.h"
#include "gate.h"
#include "led.h"
#include "ui.h"
#include "esp_now.h"
#include "esp_now_manager.h"
#include "fingerprint.h"
#include "pir.h"

class EventHandler {
public:
    EventHandler(Audio &audio, NetworkManager &network, Gate &gate, LED &led, UI &ui, ESPNow &espNow, FingerprintHandler &fingerprint,
                 PIRSensor &pir);

    void registerCallbacks(EventDispatcher &dispatcher);

private:
    Audio &audio;
    NetworkManager &network;
    Gate &gate;
    LED &led;
    UI &ui;
    ESPNow &espNow;
    FingerprintHandler &fingerprint;
    PIRSensor &pir;

    void handleTelegramAudioCommand(const Event &event);

    void handleAudioDataReceived(const Event &event);

    void handleFingerprintMatch(const Event &event);

    void handleChangeState(const Event &event);

    void handlePasswordValid(const Event &event);

    void handleChangeStateSuccess(const Event &event);

    void handleESPAudioCommand(const Event &event);

    void handleAudioDataReady(const Event &event);


    void handleFingerprintNoMatch();

    void handleResidentAuthorized();

    void handleAccessGranted();

    void handleAccessDenied();

    void handleMotionDetected();

    void handlePasswordInvalid();

    void handlePersonDetected();

    void handleRecordingSent();

    void handleFingerprintEnroll(const Event &event);

    void handleInactivityDetected(const Event &event);

    void handleVisitorEntered();

    void handlePlaceFinger(const Event &event);

    void handlePlaceFingerAgain(const Event &event);

    void handleRemoveFinger(const Event &event);

    void handleFingerprintEnrolled(const Event &event);

    void handleFingerprintEnrollFailed(const Event &event);

    void handleMotionEnable(const Event &event);

};

#endif // EVENT_HANDLER_H


###################################################

############# include\fingerprint.h #############

#ifndef FINGERPRINT_H
#define FINGERPRINT_H

#include "Adafruit_Fingerprint.h"
#include "events.h"

class FingerprintHandler {
public:
    explicit FingerprintHandler(const HardwareSerial &serial);

    void begin(EventDispatcher &dispatcher);

    void enableSensor();

    void disableSensor();

    void startEnrollment(uint8_t id);

private:
    static void fingerprintTask(void *parameter);

    uint8_t getFingerprintEnroll();


    HardwareSerial mySerial;
    bool isEnrolling = false;
    uint8_t enrollId = 0;
    bool sensorEnabled;
    Adafruit_Fingerprint fingerprint;
    static EventDispatcher *eventDispatcher;
};

#endif // FINGERPRINT_H

#################################################

############# include\gate.h #############

#ifndef GATE_H
#define GATE_H

#include <Arduino.h>
#include "events.h"

enum GateState {
    G_CLOSED,
    G_OPENING,
    G_OPEN,
    G_CLOSING
};

class Gate {
public:
    Gate();
    void begin(EventDispatcher &dispatcher);
    void openGate();
    void closeGate();

private:
    static void gateTask(void *parameter);
    void stopGate() const;
    void resumeClosing() const;
    void gateFullyClosed();

    int motorPin1;
    int motorPin2;
    int enablePin;
    int breakBeamPin;
    int reedSwitchPin;
    GateState currentState;
    unsigned long stateStartTime;
    bool personEntered;

    static EventDispatcher *eventDispatcher;
    static const unsigned long CLOSE_DELAY = 3000; // 3 seconds delay before closing
};

#endif // GATE_H

##########################################

############# include\icons.h #############

#ifndef ICONS_H
#define ICONS_H

#include <U8g2lib.h>

static const unsigned char image_volume_loud_bits[]
        U8X8_PROGMEM = {0x80, 0x83, 0x00, 0x40, 0x02, 0x01, 0x20, 0x22, 0x02, 0x10,
                        0x42, 0x04, 0x0f, 0x8a, 0x04, 0x01, 0x92, 0x08, 0x01, 0x22,
                        0x09, 0x01, 0x22, 0x09, 0x01, 0x22, 0x09, 0x01, 0x92, 0x08,
                        0x0f, 0x8a, 0x04, 0x10, 0x42, 0x04, 0x20, 0x22, 0x02, 0x40,
                        0x02, 0x01, 0x80, 0x83, 0x00, 0x00, 0x00, 0x00};

static const unsigned char image_microphone_bits[]
        U8X8_PROGMEM = {0xc0, 0x01, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03, 0xa0, 0x02,
                        0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03, 0xe8, 0x0b, 0xc8, 0x09,
                        0x10, 0x04, 0xe0, 0x03, 0x80, 0x00, 0x80, 0x00, 0xe0, 0x03,
                        0x00, 0x00};

static const unsigned char image_device_lock_bits[]
        U8X8_PROGMEM = {0xf0, 0x01, 0x08, 0x02, 0xe4, 0x04, 0x12, 0x09, 0x0a, 0x0a,
                        0x0a, 0x0a, 0xfe, 0x0f, 0x03, 0x18, 0xe5, 0x14, 0x11, 0x11,
                        0x11, 0x11, 0xa1, 0x10, 0xa1, 0x10, 0x45, 0x14, 0x03, 0x18,
                        0xfe, 0x0f};


static const unsigned char image_notification_bell_bits[]
        U8X8_PROGMEM = {0x88, 0x11, 0xc6, 0x63, 0x22, 0x44, 0x11, 0x8c, 0x11,
                        0x88, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10,
                        0x04, 0x20, 0x04, 0x20, 0x02, 0x40, 0xff, 0xff, 0x60,
                        0x06, 0xc0, 0x03, 0x00, 0x00};


static const unsigned char image_Smile_bits[]
        U8X8_PROGMEM = {0xc0, 0x0f, 0x00, 0xf0, 0x3f, 0x00, 0xf8, 0x7f, 0x00, 0xfc, 0xff, 0x00, 0xfe,
                        0xff, 0x01, 0xfe, 0xff, 0x01, 0xff, 0xff, 0x03, 0xcf, 0xcf, 0x03, 0x87, 0x87,
                        0x03, 0x87, 0x87, 0x03, 0xcf, 0xcf, 0x03, 0xff, 0xff, 0x03, 0xfe, 0xff, 0x01,
                        0xbe, 0xf7, 0x01, 0x7c, 0xf8, 0x00, 0xf8, 0x7f, 0x00, 0xf0, 0x3f, 0x00, 0xc0,
                        0x0f, 0x00};


static const unsigned char image_FaceNopower_bits[]
        U8X8_PROGMEM = {0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x60, 0x00, 0xc0, 0x00,
                        0x60, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x7e, 0x00, 0xc0, 0x0f,
                        0x3e, 0x00, 0x80, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0xf8, 0x03, 0x00, 0x00, 0x0c, 0x06, 0x00,
                        0x00, 0xfe, 0x0f, 0x00, 0x00, 0xfe, 0x0f, 0x00, 0x00, 0x0e,
                        0x0e, 0x00, 0x00, 0x00, 0x00, 0x00};

static const unsigned char image_FaceNormal_bits[]
        U8X8_PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x80, 0x07, 0x5e, 0x00,
                        0xc0, 0x0b, 0x7e, 0x00, 0xc0, 0x0f, 0x7e, 0x00, 0xc0, 0x0f,
                        0x7e, 0x00, 0xc0, 0x0f, 0x3c, 0x00, 0x80, 0x07, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x02, 0x00,
                        0x00, 0x08, 0x02, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x10,
                        0x01, 0x00, 0x00, 0xe0, 0x00, 0x00};

#endif //ICONS_H


###########################################

############# include\led.h #############

#ifndef LED_H
#define LED_H

#include <Arduino.h>
#include "events.h"

class LED {
public:
    LED();

    void begin(EventDispatcher &dispatcher);

    void turnOn();

    void turnOff();

private:
    int pin;
    static EventDispatcher *eventDispatcher;
};

#endif // LED_H

#########################################

############# include\logger.h #############

#ifndef LOGGER_H
#define LOGGER_H

#include <Arduino.h>
#include <MqttLogger.h>
#include <PubSubClient.h>

enum LogLevel {
    LOG_NONE = 0,
    LOG_ERROR,
    LOG_WARN,
    LOG_INFO,
    LOG_DEBUG
};

class Logger {
public:
    Logger();

    void begin(PubSubClient &client);

    void log(LogLevel level, const char *tag, const char *format, ...);

    static LogLevel currentLogLevel;

private:
    MqttLogger *mqttLogger;
    bool mqttInitialized;
    static const size_t LOG_BUFFER_SIZE = 256;
    char logBuffer[LOG_BUFFER_SIZE];
};

extern Logger logger;

#define LOG_E(tag, format, ...) logger.log(LOG_ERROR, tag, format, ##__VA_ARGS__)
#define LOG_W(tag, format, ...) logger.log(LOG_WARN,  tag, format, ##__VA_ARGS__)
#define LOG_I(tag, format, ...) logger.log(LOG_INFO,  tag, format, ##__VA_ARGS__)
#define LOG_D(tag, format, ...) logger.log(LOG_DEBUG, tag, format, ##__VA_ARGS__)

#endif // LOGGER_H

############################################

############# include\network_manager.h #############

#ifndef WIFI_H
#define WIFI_H

#include "WebSocketsClient.h"
#include "events.h"
#include "ArduinoJson.h"

class NetworkManager {
public:
    void begin(EventDispatcher &dispatcher);

    [[noreturn]] static void loop(void *pvParameters);

    static void sendInitMessage();

    static void sendAudioChunk(const uint8_t *data, size_t len);

    static void sendEvent(const char *eventType, const JsonObject &data);

    [[noreturn]] static void reconnectTask(void *pvParameters);

private:
    static void webSocketEvent(WStype_t type, uint8_t *payload, size_t length);

    static EventDispatcher *eventDispatcher;
    static WebSocketsClient webSocket;

};

#endif // WIFI_H


#####################################################

############# include\pir.h #############

#ifndef SENSORS_H
#define SENSORS_H

#include <Arduino.h>
#include "events.h"

class PIRSensor {
public:
    PIRSensor();

    void begin(EventDispatcher &dispatcher);

    void enableMotionDetection();

private:
    static void pirTask(void *parameter);

    static int pin;
    static EventDispatcher *eventDispatcher;
    static bool motionDetectionEnabled;
};

#endif // SENSORS_H

#########################################

############# include\sensor_task.h #############

#ifndef SENSOR_TASK_H
#define SENSOR_TASK_H

#include <Arduino.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "config.h"

void sensorTask(void *pvParameters);

#endif // SENSOR_TASK_H

#################################################

############# include\ui.h #############

#ifndef UI_H
#define UI_H

#include <U8g2lib.h>
#include <Keypad.h>
#include "events.h"

enum class UIState {
    MENU_NOTIFY_OWNER,
    MENU_ENTER_PASSWORD,
    MENU_RECORD_AUDIO,
    MENU_PLAY_AUDIO,
    OWNER_NOTIFIED,
    ENTER_PASSWORD,
    RECORDING_AUDIO,
    PLAYING_AUDIO,
    ACCESS_GRANTED,
    ACCESS_DENIED,
    MOTION_DETECTED,
    FINGERPRINT_MATCHED,
    FINGERPRINT_NO_MATCH,
    PASSWORD_CORRECT,
    PASSWORD_INCORRECT,
    SAY_CHEESE,
    WELCOME,
    NO_AUDIO_DATA,
    PLACE_FINGER,
    PLACE_FINGER_AGAIN,
    REMOVE_FINGER,
    FINGERPRINT_ENROLLED,
    FINGERPRINT_ENROLL_FAILED,
    AUDIO_MESSAGE_RECEIVED,
};

class UI {
public:
    UI();

    void begin(EventDispatcher &dispatcher);

    void update();

    void setState(UIState newState);

    void setStateFor(int seconds, UIState newState);

    void enableDisplay();

    void disableDisplay();

private:
    [[noreturn]] static void uiTask(void *parameter);

    void handleKeyPress(char key);

    void displayCurrentState();

    void handleMenuKeyPress(char key);

    void handlePasswordKeyPress(char key);

    U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2;
    bool displayEnabled;
    Keypad keypad;
    UIState currentState;
    char enteredPassword[5]{};
    bool enteringPassword;
    int passwordIndex;
    static const int menuItemCount;
    int currentMenuItem;
    static const char correctPassword[];
    static EventDispatcher *eventDispatcher;
    unsigned long lastStateChangeTime;
    static const unsigned long STATE_TIMEOUT = 30000; // 30 seconds timeout
    void displayPasswordAsAsterisks(char *password);

    TimerHandle_t stateTimer;

    static void stateTimerCallback(TimerHandle_t xTimer);

    UIState scheduledState;
};

#endif // UI_H

########################################

############# src\audio.cpp #############

#include "audio.h"
#include "config.h"
#include "logger.h"

static const char *TAG = "AUDIO";

EventDispatcher *Audio::eventDispatcher = nullptr;
volatile bool Audio::isRecording = false;
volatile bool Audio::isPlaying = false;
volatile bool Audio::isPrefetching = false;
uint8_t *Audio::audioBuffer = nullptr;
size_t Audio::audioBufferIndex = 0;
size_t Audio::audioBufferSize = AUDIO_BUFFER_SIZE;

const i2s_config_t Audio::i2sConfigRx = {
        .mode = (i2s_mode_t) (I2S_MODE_MASTER | I2S_MODE_RX),
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = static_cast<i2s_bits_per_sample_t>(BITS_PER_SAMPLE),
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = DMA_BUF_COUNT,
        .dma_buf_len = DMA_BUF_LEN,
        .use_apll = true,
        .tx_desc_auto_clear = false,
        .fixed_mclk = 0
};

const i2s_pin_config_t Audio::i2sPinConfigRx = {
        .bck_io_num = I2S_MIC_SERIAL_CLOCK,
        .ws_io_num = I2S_MIC_LEFT_RIGHT_CLOCK,
        .data_out_num = I2S_PIN_NO_CHANGE,
        .data_in_num = I2S_MIC_SERIAL_DATA
};

const i2s_config_t Audio::i2sConfigTx = {
        .mode = (i2s_mode_t) (I2S_MODE_MASTER | I2S_MODE_TX),
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = static_cast<i2s_bits_per_sample_t>(BITS_PER_SAMPLE),
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = DMA_BUF_COUNT,
        .dma_buf_len = DMA_BUF_LEN,
        .use_apll = true,
        .tx_desc_auto_clear = true,
        .fixed_mclk = 0
};

const i2s_pin_config_t Audio::i2sPinConfigTx = {
        .bck_io_num = I2S_SPEAKER_SERIAL_CLOCK,
        .ws_io_num = I2S_SPEAKER_LEFT_RIGHT_CLOCK,
        .data_out_num = I2S_SPEAKER_SERIAL_DATA,
        .data_in_num = I2S_PIN_NO_CHANGE
};

void Audio::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    // Allocate audio buffer in PSRAM
    audioBuffer = (uint8_t *) ps_malloc(AUDIO_BUFFER_SIZE);
    if (audioBuffer == nullptr) {
        LOG_E(TAG, "Failed to allocate audio buffer in PSRAM");
        return;
    }

    // Install and configure I2S drivers
    ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &i2sConfigRx, 0, nullptr));
    ESP_ERROR_CHECK(i2s_set_pin(I2S_NUM_0, &i2sPinConfigRx));
    ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_1, &i2sConfigTx, 0, nullptr));
    ESP_ERROR_CHECK(i2s_set_pin(I2S_NUM_1, &i2sPinConfigTx));

    xTaskCreatePinnedToCore(audioTask, "AudioTask", 8192, nullptr, 5, nullptr, 1);
}

size_t Audio::min(size_t a, size_t b) {
    return (a < b) ? a : b;
}

void Audio::startRecording() {
    isRecording = true;
    audioBufferIndex = 0;
    LOG_I(TAG, "Recording started");
}

void Audio::stopRecording() {
    LOG_I(TAG, "Recording stopped. Recorded %d bytes", audioBufferIndex);
    isRecording = false;
    vTaskDelay(pdMS_TO_TICKS(100)); // Wait for last audio chunk to be read
    sendAudioData();
}

void Audio::startPlayback() {
    if (audioBufferIndex > 0) {
        isPlaying = true;
        LOG_I(TAG, "Playback started with %d bytes", audioBufferIndex);
    } else {
        LOG_W(TAG, "Playback not started. No audio data available.");
        eventDispatcher->dispatchEvent({NO_AUDIO_DATA, ""});
    }
}

void Audio::stopPlayback() {
    isPlaying = false;
    vTaskDelay(100); // Wait for last audio chunk to be sent
    LOG_I(TAG, "Playback stopped");
    clearAudioBuffer();
}

void Audio::startPrefetch() {
    isPrefetching = true;
    audioBufferIndex = 0;
    LOG_I(TAG, "Prefetching started");
}

void Audio::stopPrefetch() {
    isPrefetching = false;
    LOG_I(TAG, "Prefetching stopped. Collected %d bytes", audioBufferIndex);
}

void Audio::addPrefetchData(const uint8_t *data, size_t length) {
    if (isPrefetching && (audioBufferIndex + length) <= audioBufferSize) {
        memcpy(audioBuffer + audioBufferIndex, data, length);
        audioBufferIndex += length;
    }
}

void Audio::clearAudioBuffer() {
    memset(audioBuffer, 0, audioBufferSize);
    audioBufferIndex = 0;
}

void Audio::sendAudioData() {
    const size_t chunkSize = 1024 * 8; // Send 8KB at a time
    size_t remainingBytes = audioBufferIndex;
    size_t offset = 0;

    while (remainingBytes > 0) {
        size_t bytesToSend = min(chunkSize, remainingBytes);
        eventDispatcher->dispatchEvent({AUDIO_DATA_READY, std::string(reinterpret_cast<char *>(audioBuffer + offset), bytesToSend)});
        remainingBytes -= bytesToSend;
        offset += bytesToSend;
        vTaskDelay(pdMS_TO_TICKS(10));
    }

    LOG_I(TAG, "Dispatched %u bytes of audio data in chunks", audioBufferIndex);

    eventDispatcher->dispatchEvent({RECORDING_SENT, ""});
}

void Audio::audioTask(void *parameter) {
    size_t bytesRead = 0;
    size_t bytesWritten = 0;
    while (true) {
        if (isRecording) {
            if (audioBufferIndex + DMA_BUF_LEN <= audioBufferSize) {
                esp_err_t result = i2s_read(I2S_NUM_0, audioBuffer + audioBufferIndex, DMA_BUF_LEN, &bytesRead, portMAX_DELAY);
                if (result == ESP_OK) {
                    audioBufferIndex += bytesRead;
                } else {
                    LOG_E(TAG, "Error reading from I2S: %d", result);
                }
            } else {
                LOG_W(TAG, "Audio buffer full. Stopping recording.");
                stopRecording();
            }
        } else if (isPlaying && audioBufferIndex > 0) {
            size_t bytesToWrite = min(DMA_BUF_LEN, audioBufferIndex);
            esp_err_t result = i2s_write(I2S_NUM_1, audioBuffer, bytesToWrite, &bytesWritten, portMAX_DELAY);

            if (result == ESP_OK) {
                // Shift the remaining audio data to the beginning of the buffer
                memmove(audioBuffer, audioBuffer + bytesWritten, audioBufferIndex - bytesWritten);
                audioBufferIndex -= bytesWritten;
            } else {
                LOG_E(TAG, "Error writing to I2S: %d", result);
            }
            if (audioBufferIndex == 0) {
                LOG_I(TAG, "Playback completed.");
                stopPlayback();
            }

        }
        vTaskDelay(pdMS_TO_TICKS(10)); // Small delay to prevent task from hogging CPU
    }
}

#########################################

############# src\esp_now_manager.cpp #############

#include "esp_now_manager.h"
#include "logger.h"

static const char *TAG = "ESPNow";

esp_now_peer_info_t ESPNow::peerInfo;
EventDispatcher *ESPNow::eventDispatcher = nullptr;
const uint8_t ESPNow::broadcastAddress[] = {0x34, 0x98, 0x7A, 0xB6, 0x8E, 0x88};

void ESPNow::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    if (esp_now_init() != ESP_OK) {
        LOG_E(TAG, "Error initializing ESP-NOW");
        return;
    }

    esp_now_register_recv_cb(onDataReceived);
    esp_now_register_send_cb(onDataSent);

    memcpy(peerInfo.peer_addr, broadcastAddress, 6);
    peerInfo.channel = ESPNOW_CHANNEL;
    peerInfo.encrypt = false;

    if (esp_now_add_peer(&peerInfo) != ESP_OK) {
        LOG_E(TAG, "Failed to add peer");
        return;
    }

    LOG_I(TAG, "ESP-NOW initialized successfully");
}

void ESPNow::sendCommand(const char *command) {
    esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) command, strlen(command));
    if (result != ESP_OK) {
        LOG_E(TAG, "Failed to send data: %d", result);
    } else {
        LOG_I(TAG, "Command sent successfully: %s", command);
    }
}

void ESPNow::onDataReceived(const uint8_t *mac, const uint8_t *data, int len) {
    char *receivedData = (char *) malloc(len + 1);
    memcpy(receivedData, data, len);
    receivedData[len] = '\0';

    LOG_I(TAG, "Received data: %s", receivedData);
    eventDispatcher->dispatchEvent({ESPNOW_DATA_RECEIVED, std::string(receivedData), static_cast<size_t>(len)});

    free(receivedData);
}

void ESPNow::onDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
    LOG_I(TAG, "Last Packet Send Status: %s", status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}

###################################################

############# src\events.cpp #############

#include "events.h"
#include "logger.h"

static const char *TAG = "EventDispatcher";

void EventDispatcher::registerCallback(EventType type, EventCallback callback) {
    if (type >= MAX_EVENTS) {
        LOG_E(TAG, "Event type out of range: %d", type);
        return;
    }

    callbacks.push_back({type, std::move(callback)});
    registeredEvents.set(type);
    LOG_D(TAG, "Registered callback for event type: %d", type);
}

void EventDispatcher::dispatchEvent(const Event &event) {
    if (event.type >= MAX_EVENTS) {
        LOG_E(TAG, "Invalid event type: %d", event.type);
        return;
    }

    if (!registeredEvents.test(event.type)) {
        LOG_W(TAG, "No callbacks registered for event type: %d", event.type);
        return;
    }

    LOG_D(TAG, "Dispatching event: %d, data size: %zu", event.type, event.dataLength);
    for (const auto &entry: callbacks) {
        if (entry.type == event.type) {
            entry.callback(event);
        }
    }
}

##########################################

############# src\event_handler.cpp #############

#include "event_handler.h"
#include "logger.h"
#include "esp_now_manager.h"
#include <ArduinoJson.h>

static const char *TAG = "EventHandler";

EventHandler::EventHandler(Audio &audio, NetworkManager &network, Gate &gate, LED &led, UI &ui, ESPNow &espNow,
                           FingerprintHandler &fingerprint, PIRSensor &pir)
        : audio(audio), network(network), gate(gate), led(led), ui(ui), espNow(espNow), fingerprint(fingerprint), pir(pir) {};

void EventHandler::registerCallbacks(EventDispatcher &dispatcher) {
    // Audio Commands
    dispatcher.registerCallback(CMD_TG_AUDIO, [this](const Event &e) { handleTelegramAudioCommand(e); });
    dispatcher.registerCallback(CMD_ESP_AUDIO, [this](const Event &e) { handleESPAudioCommand(e); });
    dispatcher.registerCallback(AUDIO_DATA_RECEIVED, [this](const Event &e) { handleAudioDataReceived(e); });
    dispatcher.registerCallback(AUDIO_DATA_READY, [this](const Event &e) { handleAudioDataReady(e); });

    // Authentication Events
    dispatcher.registerCallback(FINGERPRINT_MATCHED, [this](const Event &e) { handleFingerprintMatch(e); });
    dispatcher.registerCallback(FINGERPRINT_NO_MATCH, [this](const Event &e) { handleFingerprintNoMatch(); });
    dispatcher.registerCallback(PASSWORD_VALID, [this](const Event &e) { handlePasswordValid(e); });
    dispatcher.registerCallback(PASSWORD_INVALID, [this](const Event &e) { handlePasswordInvalid(); });

    // State Change Commands
    dispatcher.registerCallback(CMD_CHANGE_STATE, [this](const Event &e) { handleChangeState(e); });
    dispatcher.registerCallback(GATE_OPENED, [this](const Event &e) { handleChangeStateSuccess(e); });
    dispatcher.registerCallback(GATE_CLOSED, [this](const Event &e) { handleChangeStateSuccess(e); });
    dispatcher.registerCallback(LED_TURNED_ON, [this](const Event &e) { handleChangeStateSuccess(e); });
    dispatcher.registerCallback(LED_TURNED_OFF, [this](const Event &e) { handleChangeStateSuccess(e); });

    // Access Control
    dispatcher.registerCallback(CMD_GRANT_ACCESS, [this](const Event &e) { handleAccessGranted(); });
    dispatcher.registerCallback(CMD_DENY_ACCESS, [this](const Event &e) { handleAccessDenied(); });

    // Detection Events
    dispatcher.registerCallback(MOTION_DETECTED, [this](const Event &e) { handleMotionDetected(); });
    dispatcher.registerCallback(PERSON_DETECTED, [this](const Event &e) { handlePersonDetected(); });

    // Gate Events
    dispatcher.registerCallback(VISITOR_ENTERED, [this](const Event &e) { handleVisitorEntered(); });

    // Miscellaneous Events
    dispatcher.registerCallback(RECORDING_SENT, [this](const Event &e) { handleRecordingSent(); });
    dispatcher.registerCallback(NO_AUDIO_DATA, [this](const Event &e) { ui.setStateFor(3, UIState::NO_AUDIO_DATA); });

    // Power Saving
    dispatcher.registerCallback(INACTIVITY_DETECTED, [this](const Event &e) { handleInactivityDetected(e); });

    // Fingerprint Enrollment
    dispatcher.registerCallback(CMD_ENROLL_FINGERPRINT, [this](const Event &e) { handleFingerprintEnroll(e); });
    dispatcher.registerCallback(CMD_ENROLL_FINGERPRINT, [this](const Event &e) { handleFingerprintEnroll(e); });
    dispatcher.registerCallback(PLACE_FINGER, [this](const Event &e) { handlePlaceFinger(e); });
    dispatcher.registerCallback(PLACE_FINGER_AGAIN, [this](const Event &e) { handlePlaceFingerAgain(e); });
    dispatcher.registerCallback(REMOVE_FINGER, [this](const Event &e) { handleRemoveFinger(e); });
    dispatcher.registerCallback(FINGERPRINT_ENROLLED, [this](const Event &e) { handleFingerprintEnrolled(e); });
    dispatcher.registerCallback(FINGERPRINT_ENROLL_FAILED, [this](const Event &e) { handleFingerprintEnrollFailed(e); });

    dispatcher.registerCallback(MOTION_ENABLE, [this](const Event &e) { handleMotionEnable(e); });
}

void EventHandler::handleMotionEnable(const Event &event) {
    pir.enableMotionDetection();
}

void EventHandler::handlePlaceFinger(const Event &event) {
    ui.setStateFor(2, UIState::PLACE_FINGER);
}

void EventHandler::handlePlaceFingerAgain(const Event &event) {
    ui.setStateFor(2, UIState::PLACE_FINGER_AGAIN);
}

void EventHandler::handleRemoveFinger(const Event &event) {
    ui.setStateFor(2, UIState::REMOVE_FINGER);
}

void EventHandler::handleFingerprintEnrolled(const Event &event) {
    ui.setStateFor(2, UIState::FINGERPRINT_ENROLLED);
    network.sendEvent("fingerprint_enrolled", JsonObject());
}

void EventHandler::handleFingerprintEnrollFailed(const Event &event) {
    ui.setStateFor(2, UIState::FINGERPRINT_ENROLL_FAILED);
    network.sendEvent("fingerprint_enrollment_failed", JsonObject());

}

void EventHandler::handleTelegramAudioCommand(const Event &event) {
    std::string action = event.data;
    StaticJsonDocument<200> data;

    if (action == "start_recording") {
        audio.startRecording();
    } else if (action == "stop_recording") {
        audio.stopRecording();
    } else if (action == "start_playing") {
        audio.startPlayback();
    } else if (action == "stop_playing") {
        audio.stopPlayback();
    } else if (action == "start_prefetch") {
        audio.startPrefetch();
    } else if (action == "stop_prefetch") {
        audio.stopPrefetch();
        ui.setStateFor(2, UIState::AUDIO_MESSAGE_RECEIVED);
    } else {
        LOG_W(TAG, "Unknown Telegram audio command: %s", action.c_str());
        return;
    }

    LOG_I(TAG, "Telegram audio command executed: %s", action.c_str());
}

void EventHandler::handleFingerprintEnroll(const Event &event) {
    StaticJsonDocument<64> doc;
    deserializeJson(doc, event.data);
    uint8_t id = doc["id"];
    fingerprint.startEnrollment(id);
}

void EventHandler::handleRecordingSent() {
    StaticJsonDocument<200> data;
    data["event_type"] = "recording_sent";
    network.sendEvent("recording_sent", data.as<JsonObject>());
    LOG_I(TAG, "Recording sent event dispatched");
}

void EventHandler::handleAudioDataReady(const Event &event) {
    network.sendAudioChunk(reinterpret_cast<const uint8_t *>(event.data.c_str()), event.dataLength);
}

void EventHandler::handleESPAudioCommand(const Event &event) {
    std::string action = event.data;
    StaticJsonDocument<200> data;

    if (action == "start_recording") {
        audio.startRecording();
        data["action"] = "start_recording";
    } else if (action == "stop_recording") {
        audio.stopRecording();
        data["action"] = "stop_recording";
    } else if (action == "start_playing") {
        audio.startPlayback();
        data["action"] = "start_playing";
    } else if (action == "stop_playing") {
        audio.stopPlayback();
        data["action"] = "stop_playing";
    } else if (action == "start_prefetch") {
        audio.startPrefetch();
        data["action"] = "start_prefetch";
    } else if (action == "stop_prefetch") {
        audio.stopPrefetch();
        data["action"] = "stop_prefetch";
        ui.setStateFor(2, UIState::AUDIO_MESSAGE_RECEIVED);
    } else {
        LOG_W(TAG, "Unknown ESP audio command: %s", action.c_str());
        return;
    }

    network.sendEvent("audio", data.as<JsonObject>());
    LOG_I(TAG, "ESP audio command executed: %s", action.c_str());
}

void EventHandler::handleAudioDataReceived(const Event &event) {
    const auto *audioData = reinterpret_cast<const uint8_t *>(event.data.c_str());
    size_t dataLength = event.dataLength;
    Audio::addPrefetchData(audioData, dataLength);
}

void EventHandler::handleFingerprintMatch(const Event &event) {
    ui.setStateFor(2, UIState::FINGERPRINT_MATCHED);
    handleResidentAuthorized();
    LOG_I(TAG, "Fingerprint match found!");
}

void EventHandler::handleFingerprintNoMatch() {
    ui.setStateFor(2, UIState::FINGERPRINT_NO_MATCH);
    LOG_I(TAG, "Fingerprint no match found!");
}

void EventHandler::handlePasswordValid(const Event &event) {
    handleResidentAuthorized();
    LOG_I(TAG, "Password correct!");
}

void EventHandler::handlePasswordInvalid() {
    LOG_I(TAG, "Password incorrect!");
}

void EventHandler::handleChangeState(const Event &event) {
    StaticJsonDocument<256> doc;
    deserializeJson(doc, event.data);

    const char *device = doc["device"];
    const char *state = doc["state"];

    if (strcmp(device, "gate") == 0) {
        strcmp(state, "open") == 0 ? gate.openGate() : gate.closeGate();
    } else if (strcmp(device, "light") == 0) {
        strcmp(state, "on") == 0 ? led.turnOn() : led.turnOff();
    } else {
        LOG_W(TAG, "Unknown device: %s", device);
    }
}

void EventHandler::handleChangeStateSuccess(const Event &event) {
    StaticJsonDocument<256> data;

    if (event.type == GATE_OPENED || event.type == GATE_CLOSED) {
        data["device"] = "gate";
        data["state"] = event.type == GATE_OPENED ? "open" : "close";
    } else if (event.type == LED_TURNED_ON || event.type == LED_TURNED_OFF) {
        data["device"] = "light";
        data["state"] = event.type == LED_TURNED_ON ? "on" : "off";
    }

    network.sendEvent("change_state", data.as<JsonObject>());
}

void EventHandler::handleResidentAuthorized() {
    gate.openGate();
    LOG_I(TAG, "Resident authorized!");
}

void EventHandler::handleAccessGranted() {
    ui.setState(UIState::ACCESS_GRANTED);
    gate.openGate();
    LOG_I(TAG, "Access granted!");
}

void EventHandler::handleAccessDenied() {
    ui.setState(UIState::ACCESS_DENIED);
    LOG_I(TAG, "Access denied!");
}

void EventHandler::handleMotionDetected() {
    LOG_I(TAG, "Motion detected and visitor identification initiated!");
    ui.enableDisplay();
    vTaskDelay(pdMS_TO_TICKS(500));
    fingerprint.enableSensor();
    ui.setStateFor(2, UIState::MOTION_DETECTED);
    espNow.sendCommand("capture_image");
    network.sendEvent("motion_detected", JsonObject());
}

void EventHandler::handlePersonDetected() {
    network.sendEvent("person_detected", JsonObject());
    LOG_I(TAG, "Person detected!");
}

void EventHandler::handleVisitorEntered() {
    LOG_I(TAG, "Visitor entered the premises!");
    StaticJsonDocument<256> data;
    data["event_type"] = "visitor_entered";
    network.sendEvent("visitor_entered", data.as<JsonObject>());
}

void EventHandler::handleInactivityDetected(const Event &event) {
    ui.disableDisplay();
    fingerprint.disableSensor();
    LOG_I(TAG, "Inactivity detected, components disabled");
}


#################################################

############# src\fingerprint.cpp #############

#include "fingerprint.h"
#include "config.h"
#include "logger.h"

static const char *TAG = "FINGERPRINT";

EventDispatcher *FingerprintHandler::eventDispatcher = nullptr;

FingerprintHandler::FingerprintHandler(const HardwareSerial &serial) : mySerial(serial), fingerprint(&mySerial) {
    mySerial.begin(57600, SERIAL_8N1, FINGERPRINT_RX, FINGERPRINT_TX);
    fingerprint.begin(57600);
}

void FingerprintHandler::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    if (fingerprint.verifyPassword()) {
        LOG_I(TAG, "Found fingerprint sensor!");
        fingerprint.getTemplateCount();
        if (fingerprint.templateCount == 0) {
            LOG_E(TAG, "No fingerprint templates found. Please enroll a fingerprint first.");
        } else {
            LOG_I(TAG, "Fingerprint templates found: %d", fingerprint.templateCount);
        }
    } else {
        LOG_E(TAG, "Did not find fingerprint sensor :(");
    }

    xTaskCreate(fingerprintTask, "Fingerprint Task", 4096, this, 1, nullptr);
}

void FingerprintHandler::fingerprintTask(void *parameter) {
    auto *handler = static_cast<FingerprintHandler *>(parameter);

    while (true) {

        if (!handler->sensorEnabled) {
            vTaskDelay(pdMS_TO_TICKS(3000)); // Check every three second if sensor should be enabled
            continue;
        }

        if (handler->isEnrolling) {
            uint8_t result = handler->getFingerprintEnroll();
            if (result == FINGERPRINT_OK) {
                handler->isEnrolling = false;
                vTaskDelay(pdMS_TO_TICKS(3000)); // Wait after successful enrollment before reading another finger
            } else {
                handler->eventDispatcher->dispatchEvent({FINGERPRINT_ENROLL_FAILED, ""});
                handler->isEnrolling = false;
            }
            continue;
        }

        uint8_t p = handler->fingerprint.getImage();
        if (p == FINGERPRINT_OK) {
            LOG_I(TAG, "Image taken");
            p = handler->fingerprint.image2Tz();
            if (p == FINGERPRINT_OK) {
                LOG_I(TAG, "Image converted to template");
                p = handler->fingerprint.fingerFastSearch();
                if (p == FINGERPRINT_OK) {
                    LOG_I(TAG, "Finger found!");
                    handler->eventDispatcher->dispatchEvent({FINGERPRINT_MATCHED, ""});
                } else if (p == FINGERPRINT_NOTFOUND) {
                    LOG_I(TAG, "No match found");
                    handler->eventDispatcher->dispatchEvent({FINGERPRINT_NO_MATCH, ""});
                } else {
                    LOG_E(TAG, "Finger search error: %d", p);
                }
            } else {
                continue;
            }
        } else {
            continue;
        }
        vTaskDelay(1000);
    }
}

void FingerprintHandler::startEnrollment(uint8_t id) {
    isEnrolling = true;
    enrollId = id;
    LOG_I(TAG, "Starting fingerprint enrollment for ID %d", id);
    eventDispatcher->dispatchEvent({PLACE_FINGER, ""});
}

uint8_t FingerprintHandler::getFingerprintEnroll() {
    int p = -1;
    LOG_I(TAG, "Waiting for valid finger to enroll as #%d", enrollId);
    while (p != FINGERPRINT_OK) {
        p = fingerprint.getImage();
        switch (p) {
            case FINGERPRINT_OK:
                LOG_I(TAG, "Image taken");
                break;
            case FINGERPRINT_NOFINGER:
                LOG_D(TAG, ".");
                break;
            case FINGERPRINT_PACKETRECIEVEERR:
                LOG_E(TAG, "Communication error");
                break;
            case FINGERPRINT_IMAGEFAIL:
                LOG_E(TAG, "Imaging error");
                break;
            default:
                LOG_E(TAG, "Unknown error");
                break;
        }
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    p = fingerprint.image2Tz(1);
    switch (p) {
        case FINGERPRINT_OK:
            LOG_I(TAG, "Image converted");
            break;
        case FINGERPRINT_IMAGEMESS:
            LOG_E(TAG, "Image too messy");
            return p;
        case FINGERPRINT_PACKETRECIEVEERR:
            LOG_E(TAG, "Communication error");
            return p;
        case FINGERPRINT_FEATUREFAIL:
        case FINGERPRINT_INVALIDIMAGE:
            LOG_E(TAG, "Could not find fingerprint features");
            return p;
        default:
            LOG_E(TAG, "Unknown error");
            return p;
    }

    eventDispatcher->dispatchEvent({REMOVE_FINGER, ""});
    vTaskDelay(pdMS_TO_TICKS(2000));

    p = 0;
    while (p != FINGERPRINT_NOFINGER) {
        p = fingerprint.getImage();
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    p = -1;
    eventDispatcher->dispatchEvent({PLACE_FINGER_AGAIN, ""});
    while (p != FINGERPRINT_OK) {
        p = fingerprint.getImage();
        switch (p) {
            case FINGERPRINT_OK:
                LOG_I(TAG, "Image taken");
                break;
            case FINGERPRINT_NOFINGER:
                LOG_D(TAG, ".");
                break;
            case FINGERPRINT_PACKETRECIEVEERR:
                LOG_E(TAG, "Communication error");
                break;
            case FINGERPRINT_IMAGEFAIL:
                LOG_E(TAG, "Imaging error");
                break;
            default:
                LOG_E(TAG, "Unknown error");
                break;
        }
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    p = fingerprint.image2Tz(2);
    switch (p) {
        case FINGERPRINT_OK:
            LOG_I(TAG, "Image converted");
            break;
        case FINGERPRINT_IMAGEMESS:
            LOG_E(TAG, "Image too messy");
            return p;
        case FINGERPRINT_PACKETRECIEVEERR:
            LOG_E(TAG, "Communication error");
            return p;
        case FINGERPRINT_FEATUREFAIL:
        case FINGERPRINT_INVALIDIMAGE:
            LOG_E(TAG, "Could not find fingerprint features");
            return p;
        default:
            LOG_E(TAG, "Unknown error");
            return p;
    }

    LOG_I(TAG, "Creating model for #%d", enrollId);
    p = fingerprint.createModel();
    if (p == FINGERPRINT_OK) {
        LOG_I(TAG, "Prints matched!");
    } else if (p == FINGERPRINT_PACKETRECIEVEERR) {
        LOG_E(TAG, "Communication error");
        return p;
    } else if (p == FINGERPRINT_ENROLLMISMATCH) {
        LOG_E(TAG, "Fingerprints did not match");
        return p;
    } else {
        LOG_E(TAG, "Unknown error");
        return p;
    }

    p = fingerprint.storeModel(enrollId);
    if (p == FINGERPRINT_OK) {
        LOG_I(TAG, "Stored!");
        eventDispatcher->dispatchEvent({FINGERPRINT_ENROLLED, ""});
    } else if (p == FINGERPRINT_PACKETRECIEVEERR) {
        LOG_E(TAG, "Communication error");
        return p;
    } else if (p == FINGERPRINT_BADLOCATION) {
        LOG_E(TAG, "Could not store in that location");
        return p;
    } else if (p == FINGERPRINT_FLASHERR) {
        LOG_E(TAG, "Error writing to flash");
        return p;
    } else {
        LOG_E(TAG, "Unknown error");
        return p;
    }

    return FINGERPRINT_OK;
}

void FingerprintHandler::enableSensor() {
    sensorEnabled = true;
    LOG_I(TAG, "Fingerprint sensor enabled");
}

void FingerprintHandler::disableSensor() {
    sensorEnabled = false;
    LOG_I(TAG, "Fingerprint sensor disabled");
}



###############################################

############# src\gate.cpp #############

#include "gate.h"
#include "config.h"
#include "logger.h"

static const char *TAG = "GATE";

EventDispatcher *Gate::eventDispatcher = nullptr;

Gate::Gate()
        : motorPin1(MOTOR_PIN1),
          motorPin2(MOTOR_PIN2),
          enablePin(MOTOR_ENABLE),
          breakBeamPin(BREAK_BEAM_PIN),
          reedSwitchPin(REED_SWITCH_PIN),
          currentState(G_CLOSED),
          stateStartTime(0),
          personEntered(false) {}

void Gate::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    pinMode(motorPin1, OUTPUT);
    pinMode(motorPin2, OUTPUT);
    pinMode(enablePin, OUTPUT);
    pinMode(breakBeamPin, INPUT_PULLUP);
    pinMode(reedSwitchPin, INPUT_PULLUP);

    ledcSetup(GATE_PWM_CHANNEL, GATE_PWM_FREQ, GATE_PWM_RESOLUTION);
    ledcAttachPin(enablePin, GATE_PWM_CHANNEL);

    xTaskCreate(gateTask, "Gate Task", 4096, this, 1, nullptr);
    LOG_I(TAG, "Gate control system initialized");
}

void Gate::gateTask(void *parameter) {
    auto *gate = static_cast<Gate *>(parameter);
    while (true) {
        switch (gate->currentState) {
            case G_CLOSED:
                // Gate is closed, waiting for open command
                break;
            case G_OPENING:
                if (millis() - gate->stateStartTime >= GATE_OPERATION_TIME) {
                    gate->stopGate();
                    gate->currentState = G_OPEN;
                    gate->stateStartTime = millis();
                    gate->personEntered = false;
                    eventDispatcher->dispatchEvent({GATE_OPENED, ""});
                }
                break;
            case G_OPEN:
                if (gate->personEntered && (millis() - gate->stateStartTime >= CLOSE_DELAY)) {
                    gate->closeGate();
                }
                break;
            case G_CLOSING:
                if (digitalRead(gate->breakBeamPin) == LOW) {
                    gate->stopGate();
                    while (digitalRead(gate->breakBeamPin) == LOW) {
                        vTaskDelay(pdMS_TO_TICKS(100));
                    }
                    gate->resumeClosing();
                }

                if (digitalRead(gate->reedSwitchPin) == LOW) {
                    gate->gateFullyClosed();
                }
                break;
        }

        if (gate->currentState == G_OPEN && !gate->personEntered) {
            if (digitalRead(gate->breakBeamPin) == LOW) {
                gate->personEntered = true;
                gate->stateStartTime = millis();
                LOG_I(TAG, "Person entered, gate will close in 3 seconds");
                eventDispatcher->dispatchEvent({VISITOR_ENTERED, ""});
            }
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

void Gate::openGate() {
    if (currentState == G_CLOSED) {
        LOG_I(TAG, "Opening gate");
        digitalWrite(motorPin1, HIGH);
        digitalWrite(motorPin2, LOW);
        ledcWrite(GATE_PWM_CHANNEL, GATE_DUTY_CYCLE);
        currentState = G_OPENING;
        stateStartTime = millis();
        personEntered = false;
    }
}

void Gate::closeGate() {
    if (currentState == G_OPEN) {
        LOG_I(TAG, "Closing gate");
        digitalWrite(motorPin1, LOW);
        digitalWrite(motorPin2, HIGH);
        ledcWrite(GATE_PWM_CHANNEL, GATE_DUTY_CYCLE);
        currentState = G_CLOSING;
    }
}

void Gate::stopGate() const {
    LOG_I(TAG, "Stopping gate");
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, LOW);
    ledcWrite(GATE_PWM_CHANNEL, 0);
}

void Gate::resumeClosing() const {
    LOG_I(TAG, "Resuming gate closure");
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, HIGH);
    ledcWrite(GATE_PWM_CHANNEL, GATE_DUTY_CYCLE);
}

void Gate::gateFullyClosed() {
    vTaskDelay(pdMS_TO_TICKS(100)); // Wait for the gate to fully close
    stopGate();
    currentState = G_CLOSED;
    eventDispatcher->dispatchEvent({GATE_CLOSED, ""});
    LOG_I(TAG, "Gate fully closed");
}

########################################

############# src\led.cpp #############

#include "led.h"
#include "logger.h"
#include "config.h"

static const char *TAG = "LED";

EventDispatcher *LED::eventDispatcher = nullptr;

LED::LED() : pin(LED_STRIP_PIN) {}

void LED::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    pinMode(pin, OUTPUT);
    digitalWrite(pin, HIGH);  // Initialize the relay in OFF state
    LOG_I(TAG, "LED (Relay) initialized");
}

void LED::turnOn() {
    digitalWrite(pin, LOW);  // Trigger the relay LOW to turn ON
    LOG_I(TAG, "LED (Relay) turned on");
    eventDispatcher->dispatchEvent({LED_TURNED_ON, ""});
}

void LED::turnOff() {
    digitalWrite(pin, HIGH);  // Set the relay HIGH to turn OFF
    LOG_I(TAG, "LED (Relay) turned off");
    eventDispatcher->dispatchEvent({LED_TURNED_OFF, ""});
}

#######################################

############# src\logger.cpp #############

#include "logger.h"

LogLevel Logger::currentLogLevel = LOG_INFO;

Logger::Logger() : mqttLogger(nullptr), mqttInitialized(false) {}

void Logger::begin(PubSubClient &client) {
    if (mqttLogger != nullptr) {
        delete mqttLogger;
    }
    mqttLogger = new MqttLogger(client, "smartreceptionist/log", MqttLoggerMode::MqttAndSerial);
    mqttInitialized = true;
}

void Logger::log(LogLevel level, const char *tag, const char *format, ...) {
    if (level > currentLogLevel) return;

    va_list args;
    va_start(args, format);
    vsnprintf(logBuffer, LOG_BUFFER_SIZE, format, args);
    va_end(args);

    const char *levelStr;
    switch (level) {
        case LOG_ERROR:
            levelStr = "ERROR";
            break;
        case LOG_WARN:
            levelStr = "WARN";
            break;
        case LOG_INFO:
            levelStr = "INFO";
            break;
        case LOG_DEBUG:
            levelStr = "DEBUG";
            break;
        default:
            levelStr = "???";
            break;
    }

    char fullMessage[LOG_BUFFER_SIZE];
    snprintf(fullMessage, LOG_BUFFER_SIZE, "[%s][%s]: %s", levelStr, tag, logBuffer);

    // Add '[S3]' to the beginning of the message
    char fullMessageWithS3[LOG_BUFFER_SIZE];
    snprintf(fullMessageWithS3, LOG_BUFFER_SIZE, "[S3] %s", fullMessage);

    if (mqttInitialized && mqttLogger) {
        mqttLogger->println(fullMessageWithS3);
    } else {
        Serial.println(fullMessageWithS3);
    }
}

Logger logger;

##########################################

############# src\main.cpp #############

#include <Arduino.h>
#include "events.h"
#include "audio.h"
#include "network_manager.h"
#include "ui.h"
#include "fingerprint.h"
#include "logger.h"
#include "esp_now_manager.h"
#include "gate.h"
#include "pir.h"
#include "led.h"
#include "event_handler.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include <PubSubClient.h>
#include "config.h"
#include "sensor_task.h"

static const char *TAG = "MAIN";

EventDispatcher eventDispatcher;
NetworkManager network;
UI ui;
HardwareSerial fingerprintSerial(1);
FingerprintHandler fingerprintHandler(fingerprintSerial);
PIRSensor pirSensor;
Gate gate;
LED led;
Audio audio;
ESPNow espNow;
EventHandler eventHandler(audio, network, gate, led, ui, espNow, fingerprintHandler, pirSensor);

WiFiClient espClient;
PubSubClient mqttClient(espClient);

void setup() {
    Serial.begin(115200);
    network.begin(eventDispatcher);
    vTaskDelay(2000);

    // Initialize MQTT client
    mqttClient.setServer(WS_SERVER, 1883);
    logger.begin(mqttClient);
    mqttClient.connect("SmartReceptionist");

    // Disable brownout detector
    WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);
    LOG_I(TAG, "Brownout detector disabled");

    eventHandler.registerCallbacks(eventDispatcher);
    gate.begin(eventDispatcher);
    ui.begin(eventDispatcher);
    audio.begin(eventDispatcher);
    fingerprintHandler.begin(eventDispatcher);
    pirSensor.begin(eventDispatcher);
    led.begin(eventDispatcher);
    espNow.begin(eventDispatcher);

    LOG_I(TAG, "System initialization complete");

    // Temporary task to check sensor states
    xTaskCreate(sensorTask, "SensorTask", 2048, NULL, 1, NULL);
}

void loop() {
}

########################################

############# src\network_manager.cpp #############

#include "network_manager.h"
#include "config.h"
#include "audio.h"
#include <ArduinoJson.h>
#include <WiFi.h>
#include "logger.h"
#include <esp_system.h>

static const char *TAG = "NetworkManager";

EventDispatcher *NetworkManager::eventDispatcher = nullptr;
WebSocketsClient NetworkManager::webSocket;

void NetworkManager::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    int connectionAttempts = 0;

    while (WiFiClass::status() != WL_CONNECTED && connectionAttempts < 3) {
        vTaskDelay(pdMS_TO_TICKS(500));
        connectionAttempts++;
    }

    if (WiFiClass::status() == WL_CONNECTED) {
        LOG_I(TAG, "Connected to WiFi network");
    } else {
        LOG_E(TAG, "Failed to connect to WiFi network");
    }

    webSocket.begin(WS_SERVER, WS_PORT);
    webSocket.onEvent(webSocketEvent);

    webSocket.enableHeartbeat(15000, 3000, 2);

    xTaskCreate(NetworkManager::loop, "WiFi Task", 8192, this, 2, nullptr);
    xTaskCreate(NetworkManager::reconnectTask, "WiFi Reconnect Task", 2048, this,
                1, nullptr);
}

[[noreturn]] void NetworkManager::reconnectTask(void *pvParameters) {
    while (true) {
        if (WiFiClass::status() != WL_CONNECTED) {
            LOG_I(TAG, "Reconnecting to WiFi network...");
            WiFi.reconnect();
            int connectionAttempts = 0;
            while (WiFiClass::status() != WL_CONNECTED && connectionAttempts < 3) {
                vTaskDelay(pdMS_TO_TICKS(500));
                connectionAttempts++;
            }
            if (WiFiClass::status() == WL_CONNECTED) {
                LOG_I(TAG, "Reconnected to WiFi network");
            } else {
                LOG_E(TAG, "Failed to reconnect to WiFi network");
            }
        }
        vTaskDelay(pdMS_TO_TICKS(30000)); // Check every 30 seconds
    }
}

[[noreturn]] void NetworkManager::loop(void *pvParameters) {
    while (true) {
        webSocket.loop();
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

void NetworkManager::webSocketEvent(WStype_t type, uint8_t *payload, size_t length) {
    switch (type) {
        case WStype_DISCONNECTED:
            LOG_I(TAG, "WebSocket disconnected");
            break;
        case WStype_CONNECTED:
            LOG_I(TAG, "WebSocket connected");
            vTaskDelay(2000);
            webSocket.sendTXT(R"({"event_type":"init","data":{"device":"esp_s3"}})");
            break;
        case WStype_TEXT: {
            StaticJsonDocument<256> doc;
            DeserializationError error = deserializeJson(doc, payload, length);

            if (error) {
                LOG_E(TAG, "Failed to parse JSON: %s", error.c_str());
                return;
            }

            const char *event_type = doc["event_type"];
            if (event_type == nullptr) {
                LOG_E(TAG, "Invalid JSON: missing event_type");
                return;
            }

            LOG_I(TAG, "Received event: %s", event_type);

            if (strcmp(event_type, "audio") == 0) {
                JsonObject data = doc["data"];
                const char *action = data["action"];

                eventDispatcher->dispatchEvent({CMD_TG_AUDIO, action});

            } else if (strcmp(event_type, "change_state") == 0) {
                JsonObject data = doc["data"];
                if (!data.isNull()) {
                    String dataString;
                    serializeJson(data, dataString);
                    eventDispatcher->dispatchEvent({CMD_CHANGE_STATE, dataString.c_str()});
                } else {
                    LOG_E(TAG, "Invalid change_state event: missing data");
                }
            } else if (strcmp(event_type, "grant_access") == 0) {
                LOG_I(TAG, "Received grant access command");
                eventDispatcher->dispatchEvent({CMD_GRANT_ACCESS, ""});
            } else if (strcmp(event_type, "deny_access") == 0) {
                LOG_I(TAG, "Received deny access command");
                eventDispatcher->dispatchEvent({CMD_DENY_ACCESS, ""});
            } else if (strcmp(event_type, "reset_device") == 0) {
                LOG_I(TAG, "Received reset command. Restarting ESP32...");
                vTaskDelay(pdMS_TO_TICKS(1000));
                esp_restart();
            } else if (strcmp(event_type, "motion_enable") == 0) {
                eventDispatcher->dispatchEvent({MOTION_ENABLE, ""});
            } else if (strcmp(event_type, "enroll_fingerprint") == 0) {
                JsonObject data = doc["data"];
                if (!data.isNull()) {
                    String dataString;
                    serializeJson(data, dataString);
                    eventDispatcher->dispatchEvent({CMD_ENROLL_FINGERPRINT, dataString.c_str()});
                } else {
                    LOG_E(TAG, "Invalid enroll_fingerprint event: missing data");
                }
            } else {
                LOG_W(TAG, "Unknown event type: %s", event_type);
            }
            break;
        }
        case WStype_BIN: {
            Event event = {AUDIO_DATA_RECEIVED, std::string(reinterpret_cast<char *>(payload), length), length};
            eventDispatcher->dispatchEvent(event);
            break;
        }
        case WStype_PING:
            LOG_I(TAG, "Received PING");
            break;

        case WStype_PONG:
            LOG_I(TAG, "Received PONG");
            break;
        default:
            LOG_W(TAG, "Unhandled WebSocket event type: %d", type);
            break;
    }
}

void NetworkManager::sendAudioChunk(const uint8_t *data, size_t len) {
    if (webSocket.isConnected()) {
        // Allocate a new buffer with space for the prefix
        size_t totalLen = len + 6; // 6 is the length of "AUDIO:"
        auto *buffer = new uint8_t[totalLen];

        // Copy the prefix and the audio data
        memcpy(buffer, "AUDIO:", 6);
        memcpy(buffer + 6, data, len);

        // Send the prefixed data
        webSocket.sendBIN(buffer, totalLen);

        delete[] buffer;
    } else {
        LOG_W(TAG, "WebSocket not connected. Cannot send audio chunk.");
    }
}

void NetworkManager::sendEvent(const char *eventType, const JsonObject &data) {
    StaticJsonDocument<256> doc;
    doc["event_type"] = eventType;
    doc["data"] = data;
    char buffer[256];
    size_t length = serializeJson(doc, buffer);
    webSocket.sendTXT(buffer, length);
    LOG_I(TAG, "Sent event: %s", eventType);
}


###################################################

############# src\pir.cpp #############

#include "pir.h"
#include "logger.h"
#include "config.h"

static const char *TAG_PIR = "PIR_SENSOR";

EventDispatcher *PIRSensor::eventDispatcher = nullptr;
int PIRSensor::pin = PIR_PIN;

PIRSensor::PIRSensor() {}

void PIRSensor::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    pinMode(pin, INPUT);
    xTaskCreate(pirTask, "PIR Sensor Task", 8192, this, 1, nullptr);
    LOG_I(TAG_PIR, "PIR sensor initialized");
}

bool PIRSensor::motionDetectionEnabled = false;

void PIRSensor::enableMotionDetection() {
    motionDetectionEnabled = true;
    LOG_I(TAG_PIR, "Motion detection enabled");
}

void PIRSensor::pirTask(void *parameter) {
    auto *pirSensor = static_cast<PIRSensor *>(parameter);
    int lastState = LOW;
    while (true) {
        if (motionDetectionEnabled) {
            int currentState = digitalRead(pirSensor->pin);
            if (currentState != lastState) {
                if (currentState == HIGH) {
                    LOG_I(TAG_PIR, "Motion detected");
                    eventDispatcher->dispatchEvent({MOTION_DETECTED, ""});
                    vTaskDelay(pdMS_TO_TICKS(180000)); // Wait for 3 minutes before checking again
                }
                lastState = currentState;
            }
        }
        vTaskDelay(pdMS_TO_TICKS(10)); // Check every 10ms
    }
}



#######################################

############# src\sensor_task.cpp #############

#include "sensor_task.h"
#include "logger.h"

static const char *TAG = "SensorTask";

void sensorTask(void *pvParameters) {
    int lastBreakBeamState = -1;
    int lastDoorState = -1;

    pinMode(BREAK_BEAM_PIN, INPUT_PULLUP);
    pinMode(REED_SWITCH_PIN, INPUT_PULLUP);

    while (true) {
        int currentBreakBeamState = digitalRead(BREAK_BEAM_PIN);
        int currentDoorState = digitalRead(REED_SWITCH_PIN);

        if (currentBreakBeamState != lastBreakBeamState) {
            LOG_I(TAG, "Break beam sensor state changed: %s",
                  currentBreakBeamState == LOW ? "Beam broken" : "Beam intact");
            lastBreakBeamState = currentBreakBeamState;
        }

        if (currentDoorState != lastDoorState) {
            LOG_I(TAG, "Door sensor state changed: %s",
                  currentDoorState == LOW ? "Door closed" : "Door open");
            lastDoorState = currentDoorState;
        }

        vTaskDelay(pdMS_TO_TICKS(100)); // Check every 100ms
    }
}

###############################################

############# src\ui.cpp #############

#include "ui.h"
#include "config.h"
#include "logger.h"
#include <Wire.h>
#include "icons.h"

static const char *TAG = "UI";

const int UI::menuItemCount = 4;
const char UI::correctPassword[] = "1234";
EventDispatcher *UI::eventDispatcher = nullptr;

const byte ROWS = 4;
const byte COLS = 3;
char hexaKeys[ROWS][COLS] = {
        {'1', '2', '3'},
        {'4', '5', '6'},
        {'7', '8', '9'},
        {'*', '0', '#'}
};

byte rowPins[ROWS] = {ROW1, ROW2, ROW3, ROW4};
byte colPins[COLS] = {COL1, COL2, COL3};

UI::UI() : u8g2(U8G2_R0, U8X8_PIN_NONE),
           keypad(makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS),
           currentState(UIState::WELCOME),
           currentMenuItem(0),
           passwordIndex(0),
           lastStateChangeTime(0),
           enteringPassword(false) {
    memset(enteredPassword, 0, sizeof(enteredPassword));
}

void UI::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    Wire.begin(SDA_PIN, SCL_PIN);
    u8g2.setBusClock(400000);
    u8g2.setI2CAddress(I2C_ADDRESS * 2);
    u8g2.begin();


    xTaskCreate(uiTask, "UI Task", 4096, this, 1, nullptr);
    stateTimer = xTimerCreate("StateTimer", pdMS_TO_TICKS(1000), pdFALSE, this, stateTimerCallback);
    LOG_I(TAG, "UI initialized");
}

void UI::setStateFor(int seconds, UIState newState) {
    scheduledState = currentState;
    setState(newState);

    if (xTimerIsTimerActive(stateTimer) == pdTRUE) {
        xTimerStop(stateTimer, 0);
    }

    xTimerChangePeriod(stateTimer, pdMS_TO_TICKS(seconds * 1000), 0);
    xTimerStart(stateTimer, 0);

    LOG_I(TAG, "UI state changed to %d for %d seconds", static_cast<int>(newState), seconds);
}

void UI::stateTimerCallback(TimerHandle_t xTimer) {
    UI *ui = static_cast<UI *>(pvTimerGetTimerID(xTimer));
    ui->setState(ui->scheduledState);
    LOG_I(TAG, "UI state changed back to %d", static_cast<int>(ui->scheduledState));
}

void UI::setState(UIState newState) {
    currentState = newState;
    lastStateChangeTime = xTaskGetTickCount();
    LOG_I(TAG, "UI state changed to: %d", static_cast<int>(newState));
}

[[noreturn]] void UI::uiTask(void *parameter) {
    UI *ui = static_cast<UI *>(parameter);
    while (true) {
        ui->update();
        vTaskDelay(pdMS_TO_TICKS(40));
    }
}

void UI::enableDisplay() {
    displayEnabled = true;
    u8g2.setPowerSave(0); // Turn on display
    LOG_I(TAG, "Display enabled");
}

void UI::disableDisplay() {
    displayEnabled = false;
    u8g2.setPowerSave(1); // Turn off display
    LOG_I(TAG, "Display disabled");
}

void UI::update() {
    if (!displayEnabled) return;

    char key = keypad.getKey();
    if (key) {
        LOG_I(TAG, "Key pressed: %c", key);
        handleKeyPress(key);
    }

    unsigned long currentTime = millis();

    // Check for timeout to return to welcome screen
    if (currentTime - lastStateChangeTime > STATE_TIMEOUT &&
        currentState != UIState::WELCOME &&
        currentState != UIState::RECORDING_AUDIO &&
        currentState != UIState::PLAYING_AUDIO) {
        setState(UIState::WELCOME);
    }

    if (!enteringPassword) {
        displayCurrentState();
    }
}

void UI::handleKeyPress(char key) {
    switch (currentState) {
        case UIState::WELCOME:
            // Pressing any key will take us to the menu
            setState(UIState::MENU_NOTIFY_OWNER);
            break;
        case UIState::MENU_NOTIFY_OWNER:
        case UIState::MENU_ENTER_PASSWORD:
        case UIState::MENU_RECORD_AUDIO:
        case UIState::MENU_PLAY_AUDIO:
            handleMenuKeyPress(key);
            break;
        case UIState::ENTER_PASSWORD:
            enteringPassword = true;
            handlePasswordKeyPress(key);
            break;
        case UIState::RECORDING_AUDIO:
            if (key == '1') {
                eventDispatcher->dispatchEvent({CMD_ESP_AUDIO, "stop_recording"});
                vTaskDelay(pdMS_TO_TICKS(1000)); // Wait for one second
                setState(UIState::MENU_NOTIFY_OWNER); // Go back to the menu
            }
            break;
        case UIState::PLAYING_AUDIO:
            if (key == '1') {
                eventDispatcher->dispatchEvent({CMD_ESP_AUDIO, "stop_playing"});
                vTaskDelay(pdMS_TO_TICKS(1000)); // Wait for one second
                setState(UIState::MENU_NOTIFY_OWNER); // Go back to the menu
            }
            break;
        case UIState::PASSWORD_CORRECT:
        case UIState::PASSWORD_INCORRECT:
        case UIState::OWNER_NOTIFIED:
        case UIState::ACCESS_GRANTED:
        case UIState::ACCESS_DENIED:
        case UIState::MOTION_DETECTED:
        case UIState::FINGERPRINT_MATCHED:
        case UIState::FINGERPRINT_NO_MATCH:
        case UIState::SAY_CHEESE:
            // Pressing any key will take us back to the menu
            setState(UIState::MENU_NOTIFY_OWNER);
            break;
        default:
            break;
    }
}

void UI::handleMenuKeyPress(char key) {
    switch (key) {
        case '2':
            currentMenuItem = (currentMenuItem - 1 + menuItemCount) % menuItemCount;
            setState(static_cast<UIState>(static_cast<int>(UIState::MENU_NOTIFY_OWNER) + currentMenuItem));
            break;
        case '8':
            currentMenuItem = (currentMenuItem + 1) % menuItemCount;
            setState(static_cast<UIState>(static_cast<int>(UIState::MENU_NOTIFY_OWNER) + currentMenuItem));
            break;
        case '5':
            switch (currentState) {
                case UIState::MENU_NOTIFY_OWNER:
                    setState(UIState::OWNER_NOTIFIED);
                    eventDispatcher->dispatchEvent({PERSON_DETECTED, ""});
                    break;
                case UIState::MENU_ENTER_PASSWORD:
                    setState(UIState::ENTER_PASSWORD);
                    break;
                case UIState::MENU_RECORD_AUDIO:
                    setState(UIState::RECORDING_AUDIO);
                    eventDispatcher->dispatchEvent({CMD_ESP_AUDIO, "start_recording"});
                    break;
                case UIState::MENU_PLAY_AUDIO:
                    setState(UIState::PLAYING_AUDIO);
                    eventDispatcher->dispatchEvent({CMD_ESP_AUDIO, "start_playing"});
                    break;
            }
            break;
        default:
            LOG_I(TAG, "Invalid key: %c", key);
            break;
    }
}

void UI::handlePasswordKeyPress(char key) {
    if (key >= '0' && key <= '6' && passwordIndex < 4) {
        enteredPassword[passwordIndex++] = key;
        enteredPassword[passwordIndex] = '\0';
        displayPasswordAsAsterisks(enteredPassword);
    } else if (key == '7') {
        if (passwordIndex > 0) {
            enteredPassword[--passwordIndex] = '\0';
            displayPasswordAsAsterisks(enteredPassword);
        }
    } else if (key == '9') {
        enteringPassword = false;
        bool passwordCorrect = (strcmp(enteredPassword, correctPassword) == 0);
        eventDispatcher->dispatchEvent({passwordCorrect ? PASSWORD_VALID : PASSWORD_INVALID, ""});
        setState(passwordCorrect ? UIState::PASSWORD_CORRECT : UIState::PASSWORD_INCORRECT);
        passwordIndex = 0;
        memset(enteredPassword, 0, sizeof(enteredPassword));
    }
}

void UI::displayCurrentState() {
    u8g2.clearBuffer();
    u8g2.setFontMode(1);
    u8g2.setBitmapMode(1);

    switch (currentState) {
        case UIState::MENU_NOTIFY_OWNER:
            u8g2.drawLine(116, 7, 116, 55);
            u8g2.drawBox(113, 9, 7, 11);
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(42, 45, "OWNER");
            u8g2.drawStr(42, 29, "NOTIFY");
            u8g2.setDrawColor(2);
            u8g2.drawXBMP(14, 24, 16, 16, image_notification_bell_bits);
            break;
        case UIState::MENU_ENTER_PASSWORD:
            u8g2.drawXBMP(11, 24, 16, 16, image_device_lock_bits);
            u8g2.drawLine(116, 7, 116, 55);
            u8g2.drawBox(113, 18, 7, 11);
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(34, 28, "ENTER");
            u8g2.drawStr(34, 45, "PASSWORD");
            break;
        case UIState::MENU_RECORD_AUDIO:
            u8g2.drawXBMP(11, 24, 16, 16, image_microphone_bits);
            u8g2.drawLine(116, 7, 116, 55);
            u8g2.drawBox(113, 32, 7, 11);
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(39, 28, "RECORD");
            u8g2.drawStr(39, 45, "AUDIO");
            break;
        case UIState::MENU_PLAY_AUDIO:
            u8g2.drawLine(116, 7, 116, 55);
            u8g2.drawBox(113, 42, 7, 11);
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(39, 28, "PLAY");
            u8g2.drawStr(39, 45, "AUDIO");
            u8g2.drawXBMP(9, 24, 20, 16, image_volume_loud_bits);
            break;
        case UIState::OWNER_NOTIFIED:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(22, 21, "OWNER HAS");
            u8g2.drawStr(28, 53, "NOTIFIED");
            u8g2.drawStr(46, 37, "BEEN");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::ENTER_PASSWORD:
            u8g2.setFont(u8g2_font_t0_16b_tr);
            u8g2.drawStr(8, 26, "ENTER PASSWORD");
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(45, 47, "");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::RECORDING_AUDIO:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(10, 26, "RECORDING...");
            u8g2.setFont(u8g2_font_profont15_tr);
            u8g2.drawStr(11, 55, "PRESS 1 TO STOP");
            u8g2.drawFrame(1, 1, 126, 37);
            break;
        case UIState::PLAYING_AUDIO:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(20, 26, "PLAYING...");
            u8g2.setFont(u8g2_font_profont15_tr);
            u8g2.drawStr(11, 55, "PRESS 1 TO STOP");
            u8g2.drawFrame(1, 1, 126, 37);
            break;
        case UIState::ACCESS_GRANTED:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(34, 29, "ACCESS");
            u8g2.drawStr(31, 45, "GRANTED");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::ACCESS_DENIED:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(34, 29, "ACCESS");
            u8g2.drawStr(34, 46, "DENIED");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::MOTION_DETECTED:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(35, 30, "MOTION");
            u8g2.drawStr(28, 45, "DETECTED");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::FINGERPRINT_MATCHED:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(14, 29, "FINGERPRINT");
            u8g2.drawStr(32, 45, "MATCHED");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::FINGERPRINT_NO_MATCH:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(14, 29, "FINGERPRINT");
            u8g2.drawStr(27, 45, "NO MATCH");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::PASSWORD_CORRECT:
            u8g2.setDrawColor(2);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(31, 34, "CORRECT");
            u8g2.setDrawColor(1);
            u8g2.drawStr(27, 19, "PASSWORD");
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.drawXBMP(48, 41, 29, 14, image_FaceNormal_bits);
            break;
        case UIState::NO_AUDIO_DATA:
            u8g2.setFontMode(1);
            u8g2.setBitmapMode(1);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(28, 29, "NO AUDIO");
            u8g2.drawStr(45, 46, "DATA");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::PASSWORD_INCORRECT:
            u8g2.setDrawColor(2);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(23, 36, "INCORRECT");
            u8g2.setDrawColor(1);
            u8g2.drawStr(27, 20, "PASSWORD");
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.drawXBMP(49, 42, 29, 14, image_FaceNopower_bits);
            break;
        case UIState::SAY_CHEESE:
            u8g2.setDrawColor(2);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(17, 46, "CHEESE");
            u8g2.setDrawColor(1);
            u8g2.drawStr(18, 29, "SAY");
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.drawXBM(88, 23, 18, 18, image_Smile_bits);
            break;
        case UIState::WELCOME:
            u8g2.setDrawColor(2);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(10, 40, "RECEPTIONIST");
            u8g2.setDrawColor(1);
            u8g2.drawStr(42, 23, "SMART");
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.drawEllipse(63, 49, 2, 2);
            u8g2.drawEllipse(55, 49, 2, 2);
            u8g2.drawEllipse(71, 49, 2, 2);
            break;
        case UIState::PLACE_FINGER:
            u8g2.setFontMode(1);
            u8g2.setBitmapMode(1);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(20, 28, "PLACE YOUR");
            u8g2.drawStr(35, 44, "FINGER");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::PLACE_FINGER_AGAIN:
            u8g2.setFontMode(1);
            u8g2.setBitmapMode(1);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(18, 29, "PLACE YOUR");
            u8g2.drawStr(10, 46, "FINGER AGAIN");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::REMOVE_FINGER:
            u8g2.setFontMode(1);
            u8g2.setBitmapMode(1);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(15, 28, "REMOVE YOUR");
            u8g2.drawStr(36, 46, "FINGER");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::FINGERPRINT_ENROLLED:
            u8g2.setFontMode(1);
            u8g2.setBitmapMode(1);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(14, 28, "FINGERPRINT");
            u8g2.drawStr(22, 45, "ENROLLED!");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::FINGERPRINT_ENROLL_FAILED:
            u8g2.setFontMode(1);
            u8g2.setBitmapMode(1);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(14, 19, "FINGERPRINT");
            u8g2.drawStr(17, 36, "ENROLLMENT");
            u8g2.drawStr(37, 53, "FAILED");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::AUDIO_MESSAGE_RECEIVED:
            u8g2.setFontMode(1);
            u8g2.setBitmapMode(1);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(40, 19, "AUDIO");
            u8g2.drawStr(32, 37, "MESSAGE");
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.drawStr(27, 55, "RECEIVED");
            break;
    }
    u8g2.sendBuffer();
}

void UI::displayPasswordAsAsterisks(char *password) {
    u8g2.clearBuffer();
    u8g2.setFontMode(1);
    u8g2.setBitmapMode(1);
    u8g2.setFont(u8g2_font_t0_16b_tr);
    u8g2.drawStr(8, 26, "ENTER PASSWORD");
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(45, 47, password);
    u8g2.drawFrame(1, 1, 125, 61);
    u8g2.sendBuffer();
}

######################################


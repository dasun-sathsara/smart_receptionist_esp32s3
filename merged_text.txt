############# include\audio.h #############

#ifndef AUDIO_H
#define AUDIO_H

#include <Arduino.h>
#include <driver/i2s.h>
#include "freertos/ringbuf.h"
#include "events.h"

class Audio {
public:
    static void begin(EventDispatcher &dispatcher);

    static void startRecording();

    static void stopRecording();

    static void startPlayback();

    static void stopPlayback();

    static void addPrefetchData(const uint8_t *data, size_t length);

    static void startPrefetch();

    static void stopPrefetch();

private:
    static void audioTask(void *parameter);

    static EventDispatcher *eventDispatcher;

    // I2S configuration
    static const i2s_config_t i2sConfigRx;
    static const i2s_pin_config_t i2sPinConfigRx;
    static const i2s_config_t i2sConfigTx;
    static const i2s_pin_config_t i2sPinConfigTx;

    static volatile bool isRecording;
    static volatile bool isPlaying;
    static volatile bool isPrefetching;

    static uint8_t *audioBuffer;
    static size_t audioBufferIndex;
    static size_t audioBufferSize;

    static void clearAudioBuffer();

    static void sendAudioData();

    static size_t min(size_t a, size_t b);
};

#endif // AUDIO_H

###########################################

############# include\config.h #############

#ifndef CONFIG_H
#define CONFIG_H

#include <Arduino.h>
#include "U8g2lib.h"

// WiFi credentials
#define WIFI_SSID "LG G7"
#define WIFI_PASSWORD "12345678"

// WebSocket server details
#define WS_SERVER "35.197.142.113"
#define WS_PORT 8765

// L298N motor driver configuration
#define MOTOR_PIN1 39
#define MOTOR_PIN2 38
#define MOTOR_ENABLE 47

// Audio buffer size
#define AUDIO_BUFFER_SIZE (6 * 1024 * 1024) // 6MB buffer (Allocated in PSRAM)

// PIR sensor configuration
#define PIR_PIN 42

// Break beam sensor configuration
#define BREAK_BEAM_PIN 41

// LED strip configuration
#define LED_STRIP_PIN 40

// Door Sensor configuration
#define REED_SWITCH_PIN 14

// I2S configuration for INMP441 microphone
#define I2S_MIC_SERIAL_CLOCK 3
#define I2S_MIC_LEFT_RIGHT_CLOCK 9
#define I2S_MIC_SERIAL_DATA 10

// I2S configuration for MAX98357A amplifier
#define I2S_SPEAKER_SERIAL_CLOCK 11
#define I2S_SPEAKER_LEFT_RIGHT_CLOCK 12
#define I2S_SPEAKER_SERIAL_DATA 13

// Audio settings
#define SAMPLE_RATE 16000
#define BITS_PER_SAMPLE 16

// DMA buffer settings
#define DMA_BUF_COUNT 8
#define DMA_BUF_LEN 1024

// Fingerprint sensor configuration
#define FINGERPRINT_TX 1
#define FINGERPRINT_RX 2

// OLED I2C address
#define SDA_PIN 18
#define SCL_PIN 8
#define I2C_ADDRESS 0x3C

// Keypad configuration
#define ROW1 4
#define ROW2 5
#define ROW3 6
#define ROW4 7
#define COL1 15
#define COL2 16
#define COL3 17

// Gate control configuration
#define GATE_PWM_FREQ 30000
#define GATE_PWM_CHANNEL 0
#define GATE_PWM_RESOLUTION 8
#define GATE_DUTY_CYCLE 200
#define GATE_OPERATION_TIME 8500 // 8.5 seconds in milliseconds
#define GATE_WAIT_TIME 5000 // 5 seconds in milliseconds

#endif // CONFIG_H

############################################

############# include\esp_now_manager.h #############

#ifndef ESP_NOW_MANAGER_H
#define ESP_NOW_MANAGER_H

#include <Arduino.h>
#include <esp_now.h>
#include "events.h"

#define ESPNOW_CHANNEL 1

class ESPNow {
public:
    static void begin(EventDispatcher &dispatcher);

    static void sendCommand(const char *command);

private:
    static void onDataReceived(const uint8_t *mac, const uint8_t *data, int len);

    static void onDataSent(const uint8_t *mac_addr, esp_now_send_status_t status);

    static EventDispatcher *eventDispatcher;
    static esp_now_peer_info_t peerInfo;
    static const uint8_t broadcastAddress[];
};

#endif //ESP_NOW_MANAGER_H


#####################################################

############# include\events.h #############

#ifndef EVENTS_H
#define EVENTS_H

#include <functional>
#include <vector>
#include <bitset>
#include <cstdint>
#include <string>

constexpr size_t MAX_EVENTS = 64;

using EventType = uint8_t;

struct Event {
    EventType type;
    std::string data;
    size_t dataLength;

    Event(EventType t, const std::string &d = "", size_t s = 0) : type(t), data(d), dataLength(s == 0 ? d.size() : s) {}
};

using EventCallback = std::function<void(const Event &)>;

class EventDispatcher {
public:
    void registerCallback(EventType type, EventCallback callback);

    void dispatchEvent(const Event &event);

private:
    struct CallbackEntry {
        EventType type;
        EventCallback callback;
    };

    std::vector<CallbackEntry> callbacks;
    std::bitset<MAX_EVENTS> registeredEvents;
};

enum Events : EventType {
    WS_CONNECTED = 0,
    CMD_TG_AUDIO,
    CMD_ESP_AUDIO,
    FINGERPRINT_MATCHED,
    FINGERPRINT_NO_MATCH,
    AUDIO_DATA_RECEIVED,
    ESPNOW_DATA_RECEIVED,
    MOTION_DETECTED,
    CMD_CHANGE_STATE,
    GATE_OPENED,
    GATE_CLOSED,
    LED_TURNED_ON,
    PERSON_DETECTED,
    LED_TURNED_OFF,
    PASSWORD_VALID,
    PASSWORD_INVALID,
    CMD_GRANT_ACCESS,
    CMD_DENY_ACCESS,
    AUDIO_DATA_READY,
    RECORDING_SENT,
    NO_AUDIO_DATA,
    VISITOR_ENTERED,
};

#endif // EVENTS_H

############################################

############# include\event_handler.h #############

#ifndef EVENT_HANDLER_H
#define EVENT_HANDLER_H

#include "events.h"
#include "audio.h"
#include "network_manager.h"
#include "gate.h"
#include "led.h"
#include "ui.h"
#include "esp_now.h"
#include "esp_now_manager.h"

class EventHandler {
public:
    EventHandler(Audio &audio, NetworkManager &network, Gate &gate, LED &led, UI &ui, ESPNow &espNow);

    void registerCallbacks(EventDispatcher &dispatcher);

private:
    Audio &audio;
    NetworkManager &network;
    Gate &gate;
    LED &led;
    UI &ui;
    ESPNow &espNow;

    void handleTelegramAudioCommand(const Event &event);

    void handleAudioDataReceived(const Event &event);

    void handleFingerprintMatch(const Event &event);

    void handleChangeState(const Event &event);

    void handlePasswordValid(const Event &event);

    void handleChangeStateSuccess(const Event &event);

    void handleESPAudioCommand(const Event &event);

    void handleAudioDataReady(const Event &event);

    void handleWebSocketConnected();

    void handleFingerprintNoMatch();

    void handleResidentAuthorized();

    void handleAccessGranted();

    void handleAccessDenied();

    void handleMotionDetected();

    void handlePasswordInvalid();

    void handlePersonDetected();

    void handleRecordingSent();

    void handleBreakBeamTriggered();

    void handleGateFullyClosed();

    void handleVisitorEntered();
};

#endif // EVENT_HANDLER_H


###################################################

############# include\fingerprint.h #############

#ifndef FINGERPRINT_H
#define FINGERPRINT_H

#include "Adafruit_Fingerprint.h"
#include "events.h"

class FingerprintHandler {
public:
    explicit FingerprintHandler(const HardwareSerial &serial);

    void begin(EventDispatcher &dispatcher);

private:
    static void fingerprintTask(void *parameter);

    HardwareSerial mySerial;
    Adafruit_Fingerprint fingerprint;
    static EventDispatcher *eventDispatcher;
};

#endif // FINGERPRINT_H

#################################################

############# include\gate.h #############

#ifndef GATE_H
#define GATE_H

#include <Arduino.h>
#include "events.h"

enum GateState {
    G_CLOSED,
    G_OPENING,
    G_OPEN,
    G_CLOSING
};

class Gate {
public:
    Gate();

    void begin(EventDispatcher &dispatcher);

    void openGate();

    void closeGate();

private:
    static void gateTask(void *parameter);

    void stopGate() const;

    void resumeClosing() const;

    void gateFullyClosed();

    int motorPin1;
    int motorPin2;
    int enablePin;
    int breakBeamPin;
    int reedSwitchPin;
    GateState currentState;
    unsigned long stateStartTime;

    bool personEntered;

    // Debounce variables
    unsigned long lastBreakBeamDebounceTime;
    unsigned long lastReedSwitchDebounceTime;
    int lastBreakBeamState;
    int lastReedSwitchState;

    static EventDispatcher *eventDispatcher;
    static const unsigned long DEBOUNCE_DELAY = 50; // 50ms debounce time
    static const unsigned long CLOSE_DELAY = 3000; // 3 seconds delay before closing
};

#endif // GATE_H

##########################################

############# include\icons.h #############

#ifndef ICONS_H
#define ICONS_H

#include <U8g2lib.h>

static const unsigned char image_volume_loud_bits[]
        U8X8_PROGMEM = {0x80, 0x83, 0x00, 0x40, 0x02, 0x01, 0x20, 0x22, 0x02, 0x10,
                        0x42, 0x04, 0x0f, 0x8a, 0x04, 0x01, 0x92, 0x08, 0x01, 0x22,
                        0x09, 0x01, 0x22, 0x09, 0x01, 0x22, 0x09, 0x01, 0x92, 0x08,
                        0x0f, 0x8a, 0x04, 0x10, 0x42, 0x04, 0x20, 0x22, 0x02, 0x40,
                        0x02, 0x01, 0x80, 0x83, 0x00, 0x00, 0x00, 0x00};

static const unsigned char image_microphone_bits[]
        U8X8_PROGMEM = {0xc0, 0x01, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03, 0xa0, 0x02,
                        0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03, 0xe8, 0x0b, 0xc8, 0x09,
                        0x10, 0x04, 0xe0, 0x03, 0x80, 0x00, 0x80, 0x00, 0xe0, 0x03,
                        0x00, 0x00};

static const unsigned char image_device_lock_bits[]
        U8X8_PROGMEM = {0xf0, 0x01, 0x08, 0x02, 0xe4, 0x04, 0x12, 0x09, 0x0a, 0x0a,
                        0x0a, 0x0a, 0xfe, 0x0f, 0x03, 0x18, 0xe5, 0x14, 0x11, 0x11,
                        0x11, 0x11, 0xa1, 0x10, 0xa1, 0x10, 0x45, 0x14, 0x03, 0x18,
                        0xfe, 0x0f};


static const unsigned char image_notification_bell_bits[]
        U8X8_PROGMEM = {0x88, 0x11, 0xc6, 0x63, 0x22, 0x44, 0x11, 0x8c, 0x11,
                        0x88, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10,
                        0x04, 0x20, 0x04, 0x20, 0x02, 0x40, 0xff, 0xff, 0x60,
                        0x06, 0xc0, 0x03, 0x00, 0x00};


static const unsigned char image_Smile_bits[]
        U8X8_PROGMEM = {0xc0, 0x0f, 0x00, 0xf0, 0x3f, 0x00, 0xf8, 0x7f, 0x00, 0xfc, 0xff, 0x00, 0xfe,
                        0xff, 0x01, 0xfe, 0xff, 0x01, 0xff, 0xff, 0x03, 0xcf, 0xcf, 0x03, 0x87, 0x87,
                        0x03, 0x87, 0x87, 0x03, 0xcf, 0xcf, 0x03, 0xff, 0xff, 0x03, 0xfe, 0xff, 0x01,
                        0xbe, 0xf7, 0x01, 0x7c, 0xf8, 0x00, 0xf8, 0x7f, 0x00, 0xf0, 0x3f, 0x00, 0xc0,
                        0x0f, 0x00};


static const unsigned char image_FaceNopower_bits[]
        U8X8_PROGMEM = {0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x60, 0x00, 0xc0, 0x00,
                        0x60, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x7e, 0x00, 0xc0, 0x0f,
                        0x3e, 0x00, 0x80, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0xf8, 0x03, 0x00, 0x00, 0x0c, 0x06, 0x00,
                        0x00, 0xfe, 0x0f, 0x00, 0x00, 0xfe, 0x0f, 0x00, 0x00, 0x0e,
                        0x0e, 0x00, 0x00, 0x00, 0x00, 0x00};

static const unsigned char image_FaceNormal_bits[]
        U8X8_PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x80, 0x07, 0x5e, 0x00,
                        0xc0, 0x0b, 0x7e, 0x00, 0xc0, 0x0f, 0x7e, 0x00, 0xc0, 0x0f,
                        0x7e, 0x00, 0xc0, 0x0f, 0x3c, 0x00, 0x80, 0x07, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x02, 0x00,
                        0x00, 0x08, 0x02, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x10,
                        0x01, 0x00, 0x00, 0xe0, 0x00, 0x00};

#endif //ICONS_H


###########################################

############# include\led.h #############

#ifndef LED_H
#define LED_H

#include <Arduino.h>
#include "events.h"

class LED {
public:
    LED();

    void begin(EventDispatcher &dispatcher);

    void turnOn();

    void turnOff();

private:
    int pin;
    static EventDispatcher *eventDispatcher;
};

#endif // LED_H


#########################################

############# include\logger.h #############

#ifndef LOGGER_H
#define LOGGER_H

#include <Arduino.h>
#include <cstdarg>

enum LogLevel {
    LOG_NONE = 0,   // No logging
    LOG_ERROR,
    LOG_WARN,
    LOG_INFO,
    LOG_DEBUG
};

extern LogLevel currentLogLevel;

extern void logger(LogLevel level, const char *tag, const char *format, ...);

// Macros for convenience (similar to esp_log)
#define LOG_E(tag, format, ...) logger(LOG_ERROR, tag, format, ##__VA_ARGS__)
#define LOG_W(tag, format, ...) logger(LOG_WARN,  tag, format, ##__VA_ARGS__)
#define LOG_I(tag, format, ...) logger(LOG_INFO,  tag, format, ##__VA_ARGS__)
#define LOG_D(tag, format, ...) logger(LOG_DEBUG, tag, format, ##__VA_ARGS__)

#endif // LOGGER_H


############################################

############# include\network_manager.h #############

#ifndef WIFI_H
#define WIFI_H

#include "WebSocketsClient.h"
#include "events.h"
#include "ArduinoJson.h"

class NetworkManager {
public:
    void begin(EventDispatcher &dispatcher);

    [[noreturn]] static void loop(void *pvParameters);

    static void sendInitMessage();

    static void sendAudioChunk(const uint8_t *data, size_t len);

    static void sendEvent(const char *eventType, const JsonObject &data);

    [[noreturn]] static void reconnectTask(void *pvParameters);

private:
    static void webSocketEvent(WStype_t type, uint8_t *payload, size_t length);

    static EventDispatcher *eventDispatcher;
    static WebSocketsClient webSocket;

};

#endif // WIFI_H


#####################################################

############# include\pir.h #############

#ifndef SENSORS_H
#define SENSORS_H

#include <Arduino.h>
#include "events.h"

class PIRSensor {
public:
    PIRSensor();

    void begin(EventDispatcher &dispatcher);

private:
    static void pirTask(void *parameter);

    int pin;
    int lastState;
    int state;
    static EventDispatcher *eventDispatcher;
    unsigned long lastDebounceTime;
};
#endif // SENSORS_H

#########################################

############# include\ui.h #############

#ifndef UI_H
#define UI_H

#include <U8g2lib.h>
#include <Keypad.h>
#include "events.h"

enum class UIState {
    MENU_NOTIFY_OWNER,
    MENU_ENTER_PASSWORD,
    MENU_RECORD_AUDIO,
    MENU_PLAY_AUDIO,
    OWNER_NOTIFIED,
    ENTER_PASSWORD,
    RECORDING_AUDIO,
    PLAYING_AUDIO,
    ACCESS_GRANTED,
    ACCESS_DENIED,
    MOTION_DETECTED,
    FINGERPRINT_MATCHED,
    FINGERPRINT_NO_MATCH,
    PASSWORD_CORRECT,
    PASSWORD_INCORRECT,
    SAY_CHEESE,
    WELCOME,
    NO_AUDIO_DATA
};

class UI {
public:
    UI();

    void begin(EventDispatcher &dispatcher);

    void update();

    void setState(UIState newState);

    void setStateFor(int seconds, UIState newState);

private:
    [[noreturn]] static void uiTask(void *parameter);

    void handleKeyPress(char key);

    void displayCurrentState();

    void handleMenuKeyPress(char key);

    void handlePasswordKeyPress(char key);

    U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2;
    Keypad keypad;
    UIState currentState;
    char enteredPassword[5]{};
    bool enteringPassword;
    int passwordIndex;
    static const int menuItemCount;
    int currentMenuItem;
    static const char correctPassword[];
    static EventDispatcher *eventDispatcher;
    unsigned long lastStateChangeTime;
    static const unsigned long STATE_TIMEOUT = 30000; // 30 seconds timeout
    void displayPasswordAsAsterisks(char *password);

    unsigned long stateEndTime{};
    bool temporaryState{};
    UIState originalState{};
};

#endif // UI_H

########################################

############# src\audio.cpp #############

#include "audio.h"
#include "config.h"
#include "logger.h"

static const char *TAG = "AUDIO";

EventDispatcher *Audio::eventDispatcher = nullptr;
volatile bool Audio::isRecording = false;
volatile bool Audio::isPlaying = false;
volatile bool Audio::isPrefetching = false;
uint8_t *Audio::audioBuffer = nullptr;
size_t Audio::audioBufferIndex = 0;
size_t Audio::audioBufferSize = AUDIO_BUFFER_SIZE;

const i2s_config_t Audio::i2sConfigRx = {
        .mode = (i2s_mode_t) (I2S_MODE_MASTER | I2S_MODE_RX),
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = static_cast<i2s_bits_per_sample_t>(BITS_PER_SAMPLE),
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = DMA_BUF_COUNT,
        .dma_buf_len = DMA_BUF_LEN,
        .use_apll = true,
        .tx_desc_auto_clear = false,
        .fixed_mclk = 0
};

const i2s_pin_config_t Audio::i2sPinConfigRx = {
        .bck_io_num = I2S_MIC_SERIAL_CLOCK,
        .ws_io_num = I2S_MIC_LEFT_RIGHT_CLOCK,
        .data_out_num = I2S_PIN_NO_CHANGE,
        .data_in_num = I2S_MIC_SERIAL_DATA
};

const i2s_config_t Audio::i2sConfigTx = {
        .mode = (i2s_mode_t) (I2S_MODE_MASTER | I2S_MODE_TX),
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = static_cast<i2s_bits_per_sample_t>(BITS_PER_SAMPLE),
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = DMA_BUF_COUNT,
        .dma_buf_len = DMA_BUF_LEN,
        .use_apll = true,
        .tx_desc_auto_clear = true,
        .fixed_mclk = 0
};

const i2s_pin_config_t Audio::i2sPinConfigTx = {
        .bck_io_num = I2S_SPEAKER_SERIAL_CLOCK,
        .ws_io_num = I2S_SPEAKER_LEFT_RIGHT_CLOCK,
        .data_out_num = I2S_SPEAKER_SERIAL_DATA,
        .data_in_num = I2S_PIN_NO_CHANGE
};

void Audio::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    // Allocate audio buffer in PSRAM
    audioBuffer = (uint8_t *) ps_malloc(AUDIO_BUFFER_SIZE);
    if (audioBuffer == nullptr) {
        LOG_E(TAG, "Failed to allocate audio buffer in PSRAM");
        return;
    }

    // Install and configure I2S drivers
    ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &i2sConfigRx, 0, nullptr));
    ESP_ERROR_CHECK(i2s_set_pin(I2S_NUM_0, &i2sPinConfigRx));
    ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_1, &i2sConfigTx, 0, nullptr));
    ESP_ERROR_CHECK(i2s_set_pin(I2S_NUM_1, &i2sPinConfigTx));

    xTaskCreatePinnedToCore(audioTask, "AudioTask", 8192, nullptr, 5, nullptr, 1);
}

size_t Audio::min(size_t a, size_t b) {
    return (a < b) ? a : b;
}

void Audio::startRecording() {
    isRecording = true;
    audioBufferIndex = 0;
    LOG_I(TAG, "Recording started");
}

void Audio::stopRecording() {
    LOG_I(TAG, "Recording stopped. Recorded %d bytes", audioBufferIndex);
    isRecording = false;
    vTaskDelay(pdMS_TO_TICKS(100)); // Wait for last audio chunk to be read
    sendAudioData();
}

void Audio::startPlayback() {
    if (audioBufferIndex > 0) {
        isPlaying = true;
        LOG_I(TAG, "Playback started with %d bytes", audioBufferIndex);
    } else {
        LOG_W(TAG, "Playback not started. No audio data available.");
        eventDispatcher->dispatchEvent({NO_AUDIO_DATA, ""});
    }
}

void Audio::stopPlayback() {
    isPlaying = false;
    vTaskDelay(100); // Wait for last audio chunk to be sent
    LOG_I(TAG, "Playback stopped");
    clearAudioBuffer();
}

void Audio::startPrefetch() {
    isPrefetching = true;
    audioBufferIndex = 0;
    LOG_I(TAG, "Prefetching started");
}

void Audio::stopPrefetch() {
    isPrefetching = false;
    LOG_I(TAG, "Prefetching stopped. Collected %d bytes", audioBufferIndex);
}

void Audio::addPrefetchData(const uint8_t *data, size_t length) {
    if (isPrefetching && (audioBufferIndex + length) <= audioBufferSize) {
        memcpy(audioBuffer + audioBufferIndex, data, length);
        audioBufferIndex += length;
    }
}

void Audio::clearAudioBuffer() {
    memset(audioBuffer, 0, audioBufferSize);
    audioBufferIndex = 0;
}

void Audio::sendAudioData() {
    const size_t chunkSize = 1024 * 8; // Send 8KB at a time
    size_t remainingBytes = audioBufferIndex;
    size_t offset = 0;

    while (remainingBytes > 0) {
        size_t bytesToSend = min(chunkSize, remainingBytes);
        eventDispatcher->dispatchEvent({AUDIO_DATA_READY, std::string(reinterpret_cast<char *>(audioBuffer + offset), bytesToSend)});
        remainingBytes -= bytesToSend;
        offset += bytesToSend;
        vTaskDelay(pdMS_TO_TICKS(10));
    }

    LOG_I(TAG, "Dispatched %u bytes of audio data in chunks", audioBufferIndex);

    eventDispatcher->dispatchEvent({RECORDING_SENT, ""});
}

void Audio::audioTask(void *parameter) {
    size_t bytesRead = 0;
    size_t bytesWritten = 0;
    while (true) {
        if (isRecording) {
            if (audioBufferIndex + DMA_BUF_LEN <= audioBufferSize) {
                esp_err_t result = i2s_read(I2S_NUM_0, audioBuffer + audioBufferIndex, DMA_BUF_LEN, &bytesRead, portMAX_DELAY);
                if (result == ESP_OK) {
                    audioBufferIndex += bytesRead;
                } else {
                    LOG_E(TAG, "Error reading from I2S: %d", result);
                }
            } else {
                LOG_W(TAG, "Audio buffer full. Stopping recording.");
                stopRecording();
            }
        } else if (isPlaying && audioBufferIndex > 0) {
            size_t bytesToWrite = min(DMA_BUF_LEN, audioBufferIndex);
            esp_err_t result = i2s_write(I2S_NUM_1, audioBuffer, bytesToWrite, &bytesWritten, portMAX_DELAY);

            if (result == ESP_OK) {
                // Shift the remaining audio data to the beginning of the buffer
                memmove(audioBuffer, audioBuffer + bytesWritten, audioBufferIndex - bytesWritten);
                audioBufferIndex -= bytesWritten;
            } else {
                LOG_E(TAG, "Error writing to I2S: %d", result);
            }
            if (audioBufferIndex == 0) {
                LOG_I(TAG, "Playback completed.");
                stopPlayback();
            }

        }
        vTaskDelay(pdMS_TO_TICKS(10)); // Small delay to prevent task from hogging CPU
    }
}

#########################################

############# src\esp_now_manager.cpp #############

#include "esp_now_manager.h"
#include "logger.h"

static const char *TAG = "ESPNow";

esp_now_peer_info_t ESPNow::peerInfo;
EventDispatcher *ESPNow::eventDispatcher = nullptr;
const uint8_t ESPNow::broadcastAddress[] = {0x34, 0x98, 0x7A, 0xB6, 0x8E, 0x88};

void ESPNow::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    if (esp_now_init() != ESP_OK) {
        LOG_E(TAG, "Error initializing ESP-NOW");
        return;
    }

    esp_now_register_recv_cb(onDataReceived);
    esp_now_register_send_cb(onDataSent);

    memcpy(peerInfo.peer_addr, broadcastAddress, 6);
    peerInfo.channel = ESPNOW_CHANNEL;
    peerInfo.encrypt = false;

    if (esp_now_add_peer(&peerInfo) != ESP_OK) {
        LOG_E(TAG, "Failed to add peer");
        return;
    }

    LOG_I(TAG, "ESP-NOW initialized successfully");
}

void ESPNow::sendCommand(const char *command) {
    esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) command, strlen(command));
    if (result != ESP_OK) {
        LOG_E(TAG, "Failed to send data: %d", result);
    } else {
        LOG_I(TAG, "Command sent successfully: %s", command);
    }
}

void ESPNow::onDataReceived(const uint8_t *mac, const uint8_t *data, int len) {
    char *receivedData = (char *) malloc(len + 1);
    memcpy(receivedData, data, len);
    receivedData[len] = '\0';

    LOG_I(TAG, "Received data: %s", receivedData);
    eventDispatcher->dispatchEvent({ESPNOW_DATA_RECEIVED, std::string(receivedData), static_cast<size_t>(len)});

    free(receivedData);
}

void ESPNow::onDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
    LOG_I(TAG, "Last Packet Send Status: %s", status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}

###################################################

############# src\events.cpp #############

#include "events.h"
#include "logger.h"

static const char *TAG = "EventDispatcher";

void EventDispatcher::registerCallback(EventType type, EventCallback callback) {
    if (type >= MAX_EVENTS) {
        LOG_E(TAG, "Event type out of range: %d", type);
        return;
    }

    callbacks.push_back({type, std::move(callback)});
    registeredEvents.set(type);
    LOG_D(TAG, "Registered callback for event type: %d", type);
}

void EventDispatcher::dispatchEvent(const Event &event) {
    if (event.type >= MAX_EVENTS) {
        LOG_E(TAG, "Invalid event type: %d", event.type);
        return;
    }

    if (!registeredEvents.test(event.type)) {
        LOG_W(TAG, "No callbacks registered for event type: %d", event.type);
        return;
    }

    LOG_D(TAG, "Dispatching event: %d, data size: %zu", event.type, event.dataLength);
    for (const auto &entry: callbacks) {
        if (entry.type == event.type) {
            entry.callback(event);
        }
    }
}

##########################################

############# src\event_handler.cpp #############

#include "event_handler.h"
#include "logger.h"
#include "esp_now_manager.h"
#include <ArduinoJson.h>

static const char *TAG = "EventHandler";

EventHandler::EventHandler(Audio &audio, NetworkManager &network, Gate &gate, LED &led, UI &ui, ESPNow &espNow)
        : audio(audio), network(network), gate(gate), led(led), ui(ui), espNow(espNow) {}

void EventHandler::registerCallbacks(EventDispatcher &dispatcher) {
    // Audio Commands
    dispatcher.registerCallback(CMD_TG_AUDIO, [this](const Event &e) { handleTelegramAudioCommand(e); });
    dispatcher.registerCallback(CMD_ESP_AUDIO, [this](const Event &e) { handleESPAudioCommand(e); });
    dispatcher.registerCallback(AUDIO_DATA_RECEIVED, [this](const Event &e) { handleAudioDataReceived(e); });
    dispatcher.registerCallback(AUDIO_DATA_READY, [this](const Event &e) { handleAudioDataReady(e); });

    // WebSocket Events
    dispatcher.registerCallback(WS_CONNECTED, [this](const Event &e) { handleWebSocketConnected(); });

    // Authentication Events
    dispatcher.registerCallback(FINGERPRINT_MATCHED, [this](const Event &e) { handleFingerprintMatch(e); });
    dispatcher.registerCallback(FINGERPRINT_NO_MATCH, [this](const Event &e) { handleFingerprintNoMatch(); });
    dispatcher.registerCallback(PASSWORD_VALID, [this](const Event &e) { handlePasswordValid(e); });
    dispatcher.registerCallback(PASSWORD_INVALID, [this](const Event &e) { handlePasswordInvalid(); });

    // State Change Commands
    dispatcher.registerCallback(CMD_CHANGE_STATE, [this](const Event &e) { handleChangeState(e); });
    dispatcher.registerCallback(GATE_OPENED, [this](const Event &e) { handleChangeStateSuccess(e); });
    dispatcher.registerCallback(GATE_CLOSED, [this](const Event &e) { handleChangeStateSuccess(e); });
    dispatcher.registerCallback(LED_TURNED_ON, [this](const Event &e) { handleChangeStateSuccess(e); });
    dispatcher.registerCallback(LED_TURNED_OFF, [this](const Event &e) { handleChangeStateSuccess(e); });

    // Access Control
    dispatcher.registerCallback(CMD_GRANT_ACCESS, [this](const Event &e) { handleAccessGranted(); });
    dispatcher.registerCallback(CMD_DENY_ACCESS, [this](const Event &e) { handleAccessDenied(); });

    // Detection Events
    dispatcher.registerCallback(MOTION_DETECTED, [this](const Event &e) { handleMotionDetected(); });
    dispatcher.registerCallback(PERSON_DETECTED, [this](const Event &e) { handlePersonDetected(); });

    // Gate Events
    dispatcher.registerCallback(VISITOR_ENTERED, [this](const Event &e) { handleVisitorEntered(); });

    // Miscellaneous Events
    dispatcher.registerCallback(RECORDING_SENT, [this](const Event &e) { handleRecordingSent(); });
    dispatcher.registerCallback(NO_AUDIO_DATA, [this](const Event &e) { ui.setStateFor(3, UIState::NO_AUDIO_DATA); });
}


void EventHandler::handleTelegramAudioCommand(const Event &event) {
    std::string action = event.data;
    StaticJsonDocument<200> data;

    if (action == "start_recording") {
        audio.startRecording();
        data["action"] = "start_recording";
    } else if (action == "stop_recording") {
        audio.stopRecording();
        data["action"] = "stop_recording";
    } else if (action == "start_playing") {
        audio.startPlayback();
        data["action"] = "start_playing";
    } else if (action == "stop_playing") {
        audio.stopPlayback();
        data["action"] = "stop_playing";
    } else if (action == "start_prefetch") {
        audio.startPrefetch();
        data["action"] = "start_prefetch";
    } else if (action == "stop_prefetch") {
        audio.stopPrefetch();
        data["action"] = "stop_prefetch";
    } else {
        LOG_W(TAG, "Unknown Telegram audio command: %s", action.c_str());
        return;
    }

    LOG_I(TAG, "Telegram audio command executed: %s", action.c_str());
}

void EventHandler::handleRecordingSent() {
    StaticJsonDocument<200> data;
    data["event_type"] = "recording_sent";
    network.sendEvent("recording_sent", data.as<JsonObject>());
    LOG_I(TAG, "Recording sent event dispatched");
}

void EventHandler::handleAudioDataReady(const Event &event) {
    network.sendAudioChunk(reinterpret_cast<const uint8_t *>(event.data.c_str()), event.dataLength);
}

void EventHandler::handleESPAudioCommand(const Event &event) {
    std::string action = event.data;
    StaticJsonDocument<200> data;

    if (action == "start_recording") {
        audio.startRecording();
        data["action"] = "start_recording";
    } else if (action == "stop_recording") {
        audio.stopRecording();
        data["action"] = "stop_recording";
    } else if (action == "start_playing") {
        audio.startPlayback();
        data["action"] = "start_playing";
    } else if (action == "stop_playing") {
        audio.stopPlayback();
        data["action"] = "stop_playing";
    } else if (action == "start_prefetch") {
        audio.startPrefetch();
        data["action"] = "start_prefetch";
    } else if (action == "stop_prefetch") {
        audio.stopPrefetch();
        data["action"] = "stop_prefetch";
    } else {
        LOG_W(TAG, "Unknown ESP audio command: %s", action.c_str());
        return;
    }

    network.sendEvent("audio", data.as<JsonObject>());
    LOG_I(TAG, "ESP audio command executed: %s", action.c_str());
}


void EventHandler::handleWebSocketConnected() {
    network.sendInitMessage();
}

void EventHandler::handleAudioDataReceived(const Event &event) {
    const auto *audioData = reinterpret_cast<const uint8_t *>(event.data.c_str());
    size_t dataLength = event.dataLength;
    Audio::addPrefetchData(audioData, dataLength);
}

void EventHandler::handleFingerprintMatch(const Event &event) {
    ui.setStateFor(2, UIState::FINGERPRINT_MATCHED);
    handleResidentAuthorized();
    LOG_I(TAG, "Fingerprint match found!");
}

void EventHandler::handleFingerprintNoMatch() {
    ui.setStateFor(2, UIState::FINGERPRINT_NO_MATCH);
    LOG_I(TAG, "Fingerprint no match found!");
}

void EventHandler::handlePasswordValid(const Event &event) {
    handleResidentAuthorized();
    LOG_I(TAG, "Password correct!");
}

void EventHandler::handlePasswordInvalid() {
    LOG_I(TAG, "Password incorrect!");
}

void EventHandler::handleChangeState(const Event &event) {
    StaticJsonDocument<256> doc;
    deserializeJson(doc, event.data);

    const char *device = doc["device"];
    const char *state = doc["state"];

    if (strcmp(device, "gate") == 0) {
        strcmp(state, "open") == 0 ? gate.openGate() : gate.closeGate();
    } else if (strcmp(device, "light") == 0) {
        strcmp(state, "on") == 0 ? led.turnOn() : led.turnOff();
    } else {
        LOG_W(TAG, "Unknown device: %s", device);
    }
}

void EventHandler::handleChangeStateSuccess(const Event &event) {
    StaticJsonDocument<256> data;

    if (event.type == GATE_OPENED || event.type == GATE_CLOSED) {
        data["device"] = "gate";
        data["state"] = event.type == GATE_OPENED ? "open" : "close";
    } else if (event.type == LED_TURNED_ON || event.type == LED_TURNED_OFF) {
        data["device"] = "light";
        data["state"] = event.type == LED_TURNED_ON ? "on" : "off";
    }

    network.sendEvent("change_state", data.as<JsonObject>());
}

void EventHandler::handleResidentAuthorized() {
    gate.openGate();
    LOG_I(TAG, "Resident authorized!");
}

void EventHandler::handleAccessGranted() {
    ui.setState(UIState::ACCESS_GRANTED);
    gate.openGate();
    LOG_I(TAG, "Access granted!");
}

void EventHandler::handleAccessDenied() {
    ui.setState(UIState::ACCESS_DENIED);
    LOG_I(TAG, "Access denied!");
}

void EventHandler::handleMotionDetected() {
    ui.setStateFor(2, UIState::MOTION_DETECTED);
    espNow.sendCommand("capture_image");
    network.sendEvent("motion_detected", JsonObject());
    LOG_I(TAG, "Motion detected and visitor identification initiated!");
}

void EventHandler::handlePersonDetected() {
    network.sendEvent("person_detected", JsonObject());
    LOG_I(TAG, "Person detected!");
}

void EventHandler::handleVisitorEntered() {
    LOG_I(TAG, "Visitor entered the premises!");
    StaticJsonDocument<256> data;
    data["event_type"] = "visitor_entered";
    network.sendEvent("visitor_entered", data.as<JsonObject>());
}


#################################################

############# src\fingerprint.cpp #############

#include "fingerprint.h"
#include "config.h"
#include "logger.h"

static const char *TAG = "FINGERPRINT";

EventDispatcher *FingerprintHandler::eventDispatcher = nullptr;

FingerprintHandler::FingerprintHandler(const HardwareSerial &serial) : mySerial(serial), fingerprint(&mySerial) {
    mySerial.begin(57600, SERIAL_8N1, FINGERPRINT_RX, FINGERPRINT_TX);
    fingerprint.begin(57600);
}

void FingerprintHandler::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    if (fingerprint.verifyPassword()) {
        LOG_I(TAG, "Found fingerprint sensor!");
        fingerprint.getTemplateCount();
        if (fingerprint.templateCount == 0) {
            LOG_E(TAG, "No fingerprint templates found. Please enroll a fingerprint first.");
        } else {
            LOG_I(TAG, "Fingerprint templates found: %d", fingerprint.templateCount);
        }
    } else {
        LOG_E(TAG, "Did not find fingerprint sensor :(");
    }

    xTaskCreate(fingerprintTask, "Fingerprint Task", 4096, this, 1, nullptr);
}

void FingerprintHandler::fingerprintTask(void *parameter) {
    auto *handler = static_cast<FingerprintHandler *>(parameter);

    while (true) {
        uint8_t p = handler->fingerprint.getImage();
        if (p == FINGERPRINT_OK) {
            LOG_I(TAG, "Image taken");
            p = handler->fingerprint.image2Tz();
            if (p == FINGERPRINT_OK) {
                LOG_I(TAG, "Image converted to template");
                p = handler->fingerprint.fingerFastSearch();
                if (p == FINGERPRINT_OK) {
                    LOG_I(TAG, "Finger found!");
                    handler->eventDispatcher->dispatchEvent({FINGERPRINT_MATCHED, ""});
                } else if (p == FINGERPRINT_NOTFOUND) {
                    LOG_I(TAG, "No match found");
                    handler->eventDispatcher->dispatchEvent({FINGERPRINT_NO_MATCH, ""});
                } else {
                    LOG_E(TAG, "Finger search error: %d", p);
                }
            } else {
                continue;
            }
        } else {
            continue;
        }
        vTaskDelay(1000);
    }
}





###############################################

############# src\gate.cpp #############

#include "gate.h"
#include "config.h"
#include "logger.h"

static const char *TAG = "GATE";
EventDispatcher *Gate::eventDispatcher = nullptr;

// Constructor initializes all member variables
Gate::Gate()
        : motorPin1(MOTOR_PIN1),
          motorPin2(MOTOR_PIN2),
          enablePin(MOTOR_ENABLE),
          breakBeamPin(BREAK_BEAM_PIN),
          reedSwitchPin(REED_SWITCH_PIN),
          currentState(G_CLOSED),
          stateStartTime(0),
          lastBreakBeamDebounceTime(0),
          lastReedSwitchDebounceTime(0),
          lastBreakBeamState(HIGH),
          lastReedSwitchState(HIGH),
          personEntered(false) {}

// Initialize gate control system
void Gate::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    // Set up GPIO pins
    pinMode(motorPin1, OUTPUT);
    pinMode(motorPin2, OUTPUT);
    pinMode(enablePin, OUTPUT);
    pinMode(breakBeamPin, INPUT_PULLUP);
    pinMode(reedSwitchPin, INPUT_PULLUP);
    // Configure PWM for motor control
    ledcSetup(GATE_PWM_CHANNEL, GATE_PWM_FREQ, GATE_PWM_RESOLUTION);
    ledcAttachPin(enablePin, GATE_PWM_CHANNEL);
    // Create gate control task
    xTaskCreate(gateTask, "Gate Task", 4096, this, 1, nullptr);
    LOG_I(TAG, "Gate control system initialized");
}

// Main gate control loop
void Gate::gateTask(void *parameter) {
    auto *gate = static_cast<Gate *>(parameter);
    while (true) {
        switch (gate->currentState) {
            case G_CLOSED:
                // Gate is closed, waiting for open command
                break;
            case G_OPENING:
                // Check if gate has been opening for the full operation time
                if (millis() - gate->stateStartTime >= GATE_OPERATION_TIME) {
                    gate->stopGate();
                    gate->currentState = G_OPEN;
                    gate->stateStartTime = millis();
                    gate->personEntered = false;
                    eventDispatcher->dispatchEvent({GATE_OPENED, ""});
                }
                break;
            case G_OPEN:
                // If someone has entered and delay time has passed, close the gate
                if (gate->personEntered && (millis() - gate->stateStartTime >= CLOSE_DELAY)) {
                    gate->closeGate();
                }
                break;
            case G_CLOSING:
                // Handle break beam sensor (obstacle detection)
                int breakBeamReading = digitalRead(gate->breakBeamPin);
                if (breakBeamReading != gate->lastBreakBeamState) {
                    gate->lastBreakBeamDebounceTime = millis();
                }
                if ((millis() - gate->lastBreakBeamDebounceTime) > DEBOUNCE_DELAY) {
                    if (breakBeamReading != gate->lastBreakBeamState) {
                        gate->lastBreakBeamState = breakBeamReading;
                        if (gate->lastBreakBeamState == LOW) {
                            // Obstacle detected, stop gate and wait
                            gate->stopGate();
                            while (digitalRead(gate->breakBeamPin) == LOW) {
                                vTaskDelay(pdMS_TO_TICKS(100));
                            }
                            gate->resumeClosing();
                        }
                    }
                }
                // Handle reed switch (gate fully closed detection)
                int reedSwitchReading = digitalRead(gate->reedSwitchPin);
                if (reedSwitchReading != gate->lastReedSwitchState) {
                    gate->lastReedSwitchDebounceTime = millis();
                }
                if ((millis() - gate->lastReedSwitchDebounceTime) > DEBOUNCE_DELAY) {
                    if (reedSwitchReading != gate->lastReedSwitchState) {
                        gate->lastReedSwitchState = reedSwitchReading;
                        if (gate->lastReedSwitchState == LOW) {
                            gate->gateFullyClosed();
                        }
                    }
                }
                break;
        }

        // Detect person entering when gate is open
        if (gate->currentState == G_OPEN && !gate->personEntered) {
            int breakBeamReading = digitalRead(gate->breakBeamPin);
            if (breakBeamReading != gate->lastBreakBeamState) {
                gate->lastBreakBeamDebounceTime = millis();
            }
            if ((millis() - gate->lastBreakBeamDebounceTime) > DEBOUNCE_DELAY) {
                if (breakBeamReading != gate->lastBreakBeamState) {
                    gate->lastBreakBeamState = breakBeamReading;
                    if (gate->lastBreakBeamState == LOW) {
                        gate->personEntered = true;
                        gate->stateStartTime = millis(); // Reset timer for closing delay
                        LOG_I(TAG, "Person entered, gate will close in 3 seconds");

                        eventDispatcher->dispatchEvent({VISITOR_ENTERED, ""});
                    }
                }
            }
        }

        vTaskDelay(pdMS_TO_TICKS(10)); // Prevent task from hogging CPU
    }
}

// Start opening the gate
void Gate::openGate() {
    if (currentState == G_CLOSED) {
        LOG_I(TAG, "Opening gate");
        digitalWrite(motorPin1, HIGH);
        digitalWrite(motorPin2, LOW);
        ledcWrite(GATE_PWM_CHANNEL, GATE_DUTY_CYCLE);
        currentState = G_OPENING;
        stateStartTime = millis();
        personEntered = false;
    }
}

// Start closing the gate
void Gate::closeGate() {
    if (currentState == G_OPEN) {
        LOG_I(TAG, "Closing gate");
        digitalWrite(motorPin1, LOW);
        digitalWrite(motorPin2, HIGH);
        ledcWrite(GATE_PWM_CHANNEL, GATE_DUTY_CYCLE);
        currentState = G_CLOSING;
    }
}

// Stop gate movement
void Gate::stopGate() const {
    LOG_I(TAG, "Stopping gate");
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, LOW);
    ledcWrite(GATE_PWM_CHANNEL, 0);
}

// Resume closing the gate after obstacle is cleared
void Gate::resumeClosing() const {
    LOG_I(TAG, "Resuming gate closure");
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, HIGH);
    ledcWrite(GATE_PWM_CHANNEL, GATE_DUTY_CYCLE);
}

// Handle gate fully closed state
void Gate::gateFullyClosed() {
    stopGate();
    currentState = G_CLOSED;
    eventDispatcher->dispatchEvent({GATE_CLOSED, ""});
    LOG_I(TAG, "Gate fully closed");
}

########################################

############# src\led.cpp #############

#include "led.h"
#include "logger.h"
#include "config.h"

static const char *TAG = "LED";

EventDispatcher *LED::eventDispatcher = nullptr;

LED::LED() : pin(LED_STRIP_PIN) {}

void LED::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    pinMode(pin, OUTPUT);
    digitalWrite(pin, HIGH);
    LOG_I(TAG, "LED initialized");
}

void LED::turnOn() {
    digitalWrite(pin, LOW);
    LOG_I(TAG, "LED turned on");
    eventDispatcher->dispatchEvent({LED_TURNED_ON, ""});
}

void LED::turnOff() {
    digitalWrite(pin, HIGH);
    LOG_I(TAG, "LED turned off");
    eventDispatcher->dispatchEvent({LED_TURNED_OFF, ""});
}


#######################################

############# src\logger.cpp #############

#include "logger.h"

#define LOG_BUFFER_SIZE 128

// Define currentLogLevel
LogLevel currentLogLevel = LOG_INFO;

// Define the logger function
void logger(LogLevel level, const char *tag, const char *format, ...) {
    if (level > currentLogLevel) return; // Skip if below current log level

    char message[LOG_BUFFER_SIZE];
    va_list args;
    va_start(args, format);
    vsnprintf(message, LOG_BUFFER_SIZE, format, args);
    va_end(args);

    // Formatted output
    Serial.printf("[%s][%s]: %s\n",
                  level == LOG_ERROR ? "ERROR" : (
                          level == LOG_WARN ? "WARN" : (
                                  level == LOG_INFO ? "INFO" : (
                                          level == LOG_DEBUG ? "DEBUG" : "???"))), tag, message);
}

##########################################

############# src\main.cpp #############

#include <Arduino.h>
#include "events.h"
#include "audio.h"
#include "network_manager.h"
#include "ui.h"
#include "fingerprint.h"
#include "logger.h"
#include "esp_now_manager.h"
#include "gate.h"
#include "pir.h"
#include "led.h"
#include "config.h"
#include "event_handler.h"


static const char *TAG = "MAIN";

EventDispatcher eventDispatcher;
NetworkManager wifiHandler;
UI ui;
HardwareSerial fingerprintSerial(1);
FingerprintHandler fingerprintHandler(fingerprintSerial);
PIRSensor pirSensor;
Gate gate;
LED led;
Audio audio;
ESPNow espNow;
EventHandler eventHandler(audio, wifiHandler, gate, led, ui, espNow);

void setup() {
    eventHandler.registerCallbacks(eventDispatcher);
    Serial.begin(115200);

    wifiHandler.begin(eventDispatcher);
    ui.begin(eventDispatcher);
    audio.begin(eventDispatcher);
    fingerprintHandler.begin(eventDispatcher);
    pirSensor.begin(eventDispatcher);
    led.begin(eventDispatcher);
    espNow.begin(eventDispatcher);

    LOG_I(TAG, "System initialization complete");
}

void loop() {
}


########################################

############# src\network_manager.cpp #############

#include "network_manager.h"
#include "config.h"
#include "audio.h"
#include <ArduinoJson.h>
#include <WiFi.h>
#include "logger.h"

static const char *TAG = "NetworkManager";

EventDispatcher *NetworkManager::eventDispatcher = nullptr;
WebSocketsClient NetworkManager::webSocket;

void NetworkManager::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    int connectionAttempts = 0;

    while (WiFiClass::status() != WL_CONNECTED && connectionAttempts < 3) {
        vTaskDelay(pdMS_TO_TICKS(500));
        connectionAttempts++;
    }

    if (WiFiClass::status() == WL_CONNECTED) {
        LOG_I(TAG, "Connected to WiFi network");
    } else {
        LOG_E(TAG, "Failed to connect to WiFi network");
    }

    webSocket.begin(WS_SERVER, WS_PORT);
    webSocket.onEvent(webSocketEvent);

    webSocket.enableHeartbeat(15000, 3000, 2);

    xTaskCreate(NetworkManager::loop, "WiFi Task", 8192, this, 2, nullptr);
    xTaskCreate(NetworkManager::reconnectTask, "WiFi Reconnect Task", 2048, this,
                1, nullptr);
}

[[noreturn]] void NetworkManager::reconnectTask(void *pvParameters) {
    while (true) {
        LOG_I(TAG, "WiFi status: %d", WiFiClass::status());
        if (WiFiClass::status() != WL_CONNECTED) {
            LOG_I(TAG, "Reconnecting to WiFi network...");
            WiFi.reconnect();
            int connectionAttempts = 0;
            while (WiFiClass::status() != WL_CONNECTED && connectionAttempts < 3) {
                vTaskDelay(pdMS_TO_TICKS(500));
                connectionAttempts++;
            }
            if (WiFiClass::status() == WL_CONNECTED) {
                LOG_I(TAG, "Reconnected to WiFi network");
            } else {
                LOG_E(TAG, "Failed to reconnect to WiFi network");
            }
        }
        vTaskDelay(pdMS_TO_TICKS(30000)); // Check every 30 seconds
    }
}

[[noreturn]] void NetworkManager::loop(void *pvParameters) {
    while (true) {
        webSocket.loop();
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

void NetworkManager::webSocketEvent(WStype_t type, uint8_t *payload, size_t length) {
    switch (type) {
        case WStype_DISCONNECTED:
            LOG_I(TAG, "WebSocket disconnected");
            break;
        case WStype_CONNECTED:
            LOG_I(TAG, "WebSocket connected");
            eventDispatcher->dispatchEvent({WS_CONNECTED, ""});
            break;
        case WStype_TEXT: {
            StaticJsonDocument<256> doc;
            DeserializationError error = deserializeJson(doc, payload, length);

            if (error) {
                LOG_E(TAG, "Failed to parse JSON: %s", error.c_str());
                return;
            }

            const char *event_type = doc["event_type"];
            if (event_type == nullptr) {
                LOG_E(TAG, "Invalid JSON: missing event_type");
                return;
            }

            LOG_I(TAG, "Received event: %s", event_type);

            if (strcmp(event_type, "audio") == 0) {
                JsonObject data = doc["data"];
                const char *action = data["action"];

                eventDispatcher->dispatchEvent({CMD_TG_AUDIO, action});

            } else if (strcmp(event_type, "change_state") == 0) {
                JsonObject data = doc["data"];
                if (!data.isNull()) {
                    String dataString;
                    serializeJson(data, dataString);
                    eventDispatcher->dispatchEvent({CMD_CHANGE_STATE, dataString.c_str()});
                } else {
                    LOG_E(TAG, "Invalid change_state event: missing data");
                }
            } else if (strcmp(event_type, "grant_access") == 0) {
                eventDispatcher->dispatchEvent({CMD_GRANT_ACCESS, ""});
            } else if (strcmp(event_type, "deny_access") == 0) {
                eventDispatcher->dispatchEvent({CMD_DENY_ACCESS, ""});
            } else {
                LOG_W(TAG, "Unknown event type: %s", event_type);
            }
            break;
        }
        case WStype_BIN: {
            Event event = {AUDIO_DATA_RECEIVED, std::string(reinterpret_cast<char *>(payload), length), length};
            eventDispatcher->dispatchEvent(event);
            break;
        }
        case WStype_PING:
            LOG_I(TAG, "Received PING");
            break;

        case WStype_PONG:
            LOG_I(TAG, "Received PONG");
            break;
        default:
            LOG_W(TAG, "Unhandled WebSocket event type: %d", type);
            break;
    }
}

void NetworkManager::sendInitMessage() {
    LOG_I(TAG, "Sent init message");
    webSocket.sendTXT(R"({"event_type":"init","data":{"device":"esp_s3"}})");
}

void NetworkManager::sendAudioChunk(const uint8_t *data, size_t len) {
    if (webSocket.isConnected()) {
        // Allocate a new buffer with space for the prefix
        size_t totalLen = len + 6; // 6 is the length of "AUDIO:"
        auto *buffer = new uint8_t[totalLen];

        // Copy the prefix and the audio data
        memcpy(buffer, "AUDIO:", 6);
        memcpy(buffer + 6, data, len);

        // Send the prefixed data
        webSocket.sendBIN(buffer, totalLen);

        delete[] buffer;
    } else {
        LOG_W(TAG, "WebSocket not connected. Cannot send audio chunk.");
    }
}

void NetworkManager::sendEvent(const char *eventType, const JsonObject &data) {
    StaticJsonDocument<256> doc;
    doc["event_type"] = eventType;
    doc["data"] = data;
    char buffer[256];
    size_t length = serializeJson(doc, buffer);
    webSocket.sendTXT(buffer, length);
    LOG_I(TAG, "Sent event: %s", eventType);
}


###################################################

############# src\pir.cpp #############

#include "pir.h"
#include "logger.h"
#include "config.h"

static const char *TAG_PIR = "PIR_SENSOR";

EventDispatcher *PIRSensor::eventDispatcher = nullptr;

PIRSensor::PIRSensor() : lastDebounceTime(0), lastState(LOW), state(LOW) { pin = PIR_PIN; }

void PIRSensor::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    pinMode(pin, INPUT);
    xTaskCreate(pirTask, "PIR Sensor Task", 2048, this, 1, nullptr);
    LOG_I(TAG_PIR, "PIR sensor initialized");
}

void PIRSensor::pirTask(void *parameter) {
    auto *pirSensor = static_cast<PIRSensor *>(parameter);
    const unsigned long debounceDelay = 50; // 50ms debounce time
    const unsigned long cooldownTime = 60000; // 1 minute cooldown
    unsigned long lastTriggerTime = 0;

    while (true) {
        int reading = digitalRead(pirSensor->pin);

        if (reading != pirSensor->lastState) {
            pirSensor->lastDebounceTime = millis();
        }

        if ((millis() - pirSensor->lastDebounceTime) > debounceDelay) {
            if (reading != pirSensor->state) {
                pirSensor->state = reading;

                if (pirSensor->state == HIGH && (millis() - lastTriggerTime) > cooldownTime) {
                    eventDispatcher->dispatchEvent({MOTION_DETECTED, ""});
                    lastTriggerTime = millis();
                }
            }
        }

        pirSensor->lastState = reading;
        vTaskDelay(pdMS_TO_TICKS(10)); // Check every 10ms
    }
}


#######################################

############# src\ui.cpp #############

#include "ui.h"
#include "config.h"
#include "logger.h"
#include <Wire.h>
#include "icons.h"

static const char *TAG = "UI";

const int UI::menuItemCount = 4;
const char UI::correctPassword[] = "1234";
EventDispatcher *UI::eventDispatcher = nullptr;

const byte ROWS = 4;
const byte COLS = 3;
char hexaKeys[ROWS][COLS] = {
        {'1', '2', '3'},
        {'4', '5', '6'},
        {'7', '8', '9'},
        {'*', '0', '#'}
};

byte rowPins[ROWS] = {ROW1, ROW2, ROW3, ROW4};
byte colPins[COLS] = {COL1, COL2, COL3};

UI::UI() : u8g2(U8G2_R0, U8X8_PIN_NONE),
           keypad(makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS),
           currentState(UIState::WELCOME),
           currentMenuItem(0),
           passwordIndex(0),
           lastStateChangeTime(0),
           enteringPassword(false) {
    memset(enteredPassword, 0, sizeof(enteredPassword));
}

void UI::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    Wire.begin(SDA_PIN, SCL_PIN);
    u8g2.setBusClock(400000);
    u8g2.setI2CAddress(I2C_ADDRESS * 2);
    u8g2.begin();


    xTaskCreate(uiTask, "UI Task", 4096, this, 1, nullptr);
    LOG_I(TAG, "UI initialized");
}

[[noreturn]] void UI::uiTask(void *parameter) {
    UI *ui = static_cast<UI *>(parameter);
    while (true) {
        ui->update();
        vTaskDelay(pdMS_TO_TICKS(40));
    }
}

void UI::update() {
    char key = keypad.getKey();
    if (key) {
        LOG_I(TAG, "Key pressed: %c", key);
        handleKeyPress(key);
    }

    unsigned long currentTime = millis();

    // Check for temporary state expiration
    if (temporaryState && currentTime >= stateEndTime) {
        setState(originalState);
        temporaryState = false;
        LOG_I(TAG, "UI state changed back to %d", static_cast<int>(originalState));
    }

    // Check for timeout to return to welcome screen
    if (currentTime - lastStateChangeTime > STATE_TIMEOUT &&
        currentState != UIState::WELCOME &&
        currentState != UIState::RECORDING_AUDIO &&
        currentState != UIState::PLAYING_AUDIO) {
        setState(UIState::WELCOME);
    }

    if (!enteringPassword) {
        displayCurrentState();
    }
}

void UI::setState(UIState newState) {
    currentState = newState;
    lastStateChangeTime = millis();
    LOG_I(TAG, "UI state changed to: %d", static_cast<int>(newState));
}

void UI::setStateFor(int seconds, UIState newState) {
    setState(newState);
    stateEndTime = millis() + (seconds * 1000);
    temporaryState = true;
    originalState = currentState;
    LOG_I(TAG, "UI state changed to %d for %d seconds", static_cast<int>(newState), seconds);
}

void UI::handleKeyPress(char key) {
    switch (currentState) {
        case UIState::WELCOME:
            // Pressing any key will take us to the menu
            setState(UIState::MENU_NOTIFY_OWNER);
            break;
        case UIState::MENU_NOTIFY_OWNER:
        case UIState::MENU_ENTER_PASSWORD:
        case UIState::MENU_RECORD_AUDIO:
        case UIState::MENU_PLAY_AUDIO:
            handleMenuKeyPress(key);
            break;
        case UIState::ENTER_PASSWORD:
            enteringPassword = true;
            handlePasswordKeyPress(key);
            break;
        case UIState::RECORDING_AUDIO:
            if (key == '1') {
                eventDispatcher->dispatchEvent({CMD_ESP_AUDIO, "stop_recording"});
                vTaskDelay(pdMS_TO_TICKS(1000)); // Wait for one second
                setState(UIState::MENU_NOTIFY_OWNER); // Go back to the menu
            }
            break;
        case UIState::PLAYING_AUDIO:
            if (key == '1') {
                eventDispatcher->dispatchEvent({CMD_ESP_AUDIO, "stop_playing"});
                vTaskDelay(pdMS_TO_TICKS(1000)); // Wait for one second
                setState(UIState::MENU_NOTIFY_OWNER); // Go back to the menu
            }
            break;
        case UIState::PASSWORD_CORRECT:
        case UIState::PASSWORD_INCORRECT:
        case UIState::OWNER_NOTIFIED:
        case UIState::ACCESS_GRANTED:
        case UIState::ACCESS_DENIED:
        case UIState::MOTION_DETECTED:
        case UIState::FINGERPRINT_MATCHED:
        case UIState::FINGERPRINT_NO_MATCH:
        case UIState::SAY_CHEESE:
            // Pressing any key will take us back to the menu
            setState(UIState::MENU_NOTIFY_OWNER);
            break;
        default:
            break;
    }
}

void UI::handleMenuKeyPress(char key) {
    switch (key) {
        case '2':
            currentMenuItem = (currentMenuItem - 1 + menuItemCount) % menuItemCount;
            setState(static_cast<UIState>(static_cast<int>(UIState::MENU_NOTIFY_OWNER) + currentMenuItem));
            break;
        case '8':
            currentMenuItem = (currentMenuItem + 1) % menuItemCount;
            setState(static_cast<UIState>(static_cast<int>(UIState::MENU_NOTIFY_OWNER) + currentMenuItem));
            break;
        case '5':
            switch (currentState) {
                case UIState::MENU_NOTIFY_OWNER:
                    setState(UIState::OWNER_NOTIFIED);
                    eventDispatcher->dispatchEvent({PERSON_DETECTED, ""});
                    break;
                case UIState::MENU_ENTER_PASSWORD:
                    setState(UIState::ENTER_PASSWORD);
                    break;
                case UIState::MENU_RECORD_AUDIO:
                    setState(UIState::RECORDING_AUDIO);
                    eventDispatcher->dispatchEvent({CMD_ESP_AUDIO, "start_recording"});
                    break;
                case UIState::MENU_PLAY_AUDIO:
                    setState(UIState::PLAYING_AUDIO);
                    eventDispatcher->dispatchEvent({CMD_ESP_AUDIO, "start_playing"});
                    break;
            }
            break;
        default:
            LOG_I(TAG, "Invalid key: %c", key);
            break;
    }
}

void UI::handlePasswordKeyPress(char key) {
    if (key >= '0' && key <= '6' && passwordIndex < 4) {
        enteredPassword[passwordIndex++] = key;
        enteredPassword[passwordIndex] = '\0';
        displayPasswordAsAsterisks(enteredPassword);
    } else if (key == '7') {
        if (passwordIndex > 0) {
            enteredPassword[--passwordIndex] = '\0';
            displayPasswordAsAsterisks(enteredPassword);
        }
    } else if (key == '9') {
        enteringPassword = false;
        bool passwordCorrect = (strcmp(enteredPassword, correctPassword) == 0);
        eventDispatcher->dispatchEvent({passwordCorrect ? PASSWORD_VALID : PASSWORD_INVALID, ""});
        setState(passwordCorrect ? UIState::PASSWORD_CORRECT : UIState::PASSWORD_INCORRECT);
        passwordIndex = 0;
        memset(enteredPassword, 0, sizeof(enteredPassword));
    }
}

void UI::displayCurrentState() {
    u8g2.clearBuffer();
    u8g2.setFontMode(1);
    u8g2.setBitmapMode(1);

    switch (currentState) {
        case UIState::MENU_NOTIFY_OWNER:
            u8g2.drawLine(116, 7, 116, 55);
            u8g2.drawBox(113, 9, 7, 11);
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(42, 45, "OWNER");
            u8g2.drawStr(42, 29, "NOTIFY");
            u8g2.setDrawColor(2);
            u8g2.drawXBMP(14, 24, 16, 16, image_notification_bell_bits);
            break;
        case UIState::MENU_ENTER_PASSWORD:
            u8g2.drawXBMP(11, 24, 16, 16, image_device_lock_bits);
            u8g2.drawLine(116, 7, 116, 55);
            u8g2.drawBox(113, 18, 7, 11);
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(34, 28, "ENTER");
            u8g2.drawStr(34, 45, "PASSWORD");
            break;
        case UIState::MENU_RECORD_AUDIO:
            u8g2.drawXBMP(11, 24, 16, 16, image_microphone_bits);
            u8g2.drawLine(116, 7, 116, 55);
            u8g2.drawBox(113, 32, 7, 11);
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(39, 28, "RECORD");
            u8g2.drawStr(39, 45, "AUDIO");
            break;
        case UIState::MENU_PLAY_AUDIO:
            u8g2.drawLine(116, 7, 116, 55);
            u8g2.drawBox(113, 42, 7, 11);
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(39, 28, "PLAY");
            u8g2.drawStr(39, 45, "AUDIO");
            u8g2.drawXBMP(9, 24, 20, 16, image_volume_loud_bits);
            break;
        case UIState::OWNER_NOTIFIED:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(22, 21, "OWNER HAS");
            u8g2.drawStr(28, 53, "NOTIFIED");
            u8g2.drawStr(46, 37, "BEEN");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::ENTER_PASSWORD:
            u8g2.setFont(u8g2_font_t0_16b_tr);
            u8g2.drawStr(8, 26, "ENTER PASSWORD");
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(45, 47, "");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::RECORDING_AUDIO:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(10, 26, "RECORDING...");
            u8g2.setFont(u8g2_font_profont15_tr);
            u8g2.drawStr(11, 55, "PRESS 1 TO STOP");
            u8g2.drawFrame(1, 1, 126, 37);
            break;
        case UIState::PLAYING_AUDIO:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(20, 26, "PLAYING...");
            u8g2.setFont(u8g2_font_profont15_tr);
            u8g2.drawStr(11, 55, "PRESS 1 TO STOP");
            u8g2.drawFrame(1, 1, 126, 37);
            break;
        case UIState::ACCESS_GRANTED:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(34, 29, "ACCESS");
            u8g2.drawStr(31, 45, "GRANTED");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::ACCESS_DENIED:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(34, 29, "ACCESS");
            u8g2.drawStr(34, 46, "DENIED");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::MOTION_DETECTED:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(35, 30, "MOTION");
            u8g2.drawStr(28, 45, "DETECTED");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::FINGERPRINT_MATCHED:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(14, 29, "FINGERPRINT");
            u8g2.drawStr(32, 45, "MATCHED");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::FINGERPRINT_NO_MATCH:
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(14, 29, "FINGERPRINT");
            u8g2.drawStr(27, 45, "NO MATCH");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::PASSWORD_CORRECT:
            u8g2.setDrawColor(2);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(31, 34, "CORRECT");
            u8g2.setDrawColor(1);
            u8g2.drawStr(27, 19, "PASSWORD");
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.drawXBMP(48, 41, 29, 14, image_FaceNormal_bits);
            break;
        case UIState::NO_AUDIO_DATA:
            u8g2.setFontMode(1);
            u8g2.setBitmapMode(1);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(28, 29, "NO AUDIO");
            u8g2.drawStr(45, 46, "DATA");
            u8g2.drawFrame(1, 1, 125, 61);
            break;
        case UIState::PASSWORD_INCORRECT:
            u8g2.setDrawColor(2);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(23, 36, "INCORRECT");
            u8g2.setDrawColor(1);
            u8g2.drawStr(27, 20, "PASSWORD");
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.drawXBMP(49, 42, 29, 14, image_FaceNopower_bits);
            break;
        case UIState::SAY_CHEESE:
            u8g2.setDrawColor(2);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(17, 46, "CHEESE");
            u8g2.setDrawColor(1);
            u8g2.drawStr(18, 29, "SAY");
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.drawXBM(88, 23, 18, 18, image_Smile_bits);
            break;
        case UIState::WELCOME:
            u8g2.setDrawColor(2);
            u8g2.setFont(u8g2_font_profont17_tr);
            u8g2.drawStr(10, 40, "RECEPTIONIST");
            u8g2.setDrawColor(1);
            u8g2.drawStr(42, 23, "SMART");
            u8g2.drawFrame(1, 1, 125, 61);
            u8g2.drawEllipse(63, 49, 2, 2);
            u8g2.drawEllipse(55, 49, 2, 2);
            u8g2.drawEllipse(71, 49, 2, 2);
            break;
    }
    u8g2.sendBuffer();
}

void UI::displayPasswordAsAsterisks(char *password) {
    u8g2.clearBuffer();
    u8g2.setFontMode(1);
    u8g2.setBitmapMode(1);
    u8g2.setFont(u8g2_font_t0_16b_tr);
    u8g2.drawStr(8, 26, "ENTER PASSWORD");
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(45, 47, password);
    u8g2.drawFrame(1, 1, 125, 61);
    u8g2.sendBuffer();
}

######################################


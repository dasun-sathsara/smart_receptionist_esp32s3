############# include\audio.h #############

// audio.h
#ifndef AUDIO_H
#define AUDIO_H

#include <Arduino.h>
#include <driver/i2s.h>
#include "events.h"

class Audio {
public:
     void begin();

    static void startRecording();

    static void stopRecording();

    static void startPlayback();

    static void stopPlayback();

    static void addDataToBuffer(const uint8_t *data, size_t length);

private:
    [[noreturn]] static void i2sReaderTask(void *parameter);

    [[noreturn]] static void i2sWriterTask(void *parameter);

    static SemaphoreHandle_t i2sBufferMutex;
    static uint8_t *i2sBuffer;
    static size_t i2sBufferSize;
    static volatile size_t i2sBufferHead;
    static volatile size_t i2sBufferTail;
    static TaskHandle_t i2sReaderTaskHandle;
    static TaskHandle_t i2sWriterTaskHandle;

    // I2S configuration
    static const i2s_config_t i2sConfigRx;
    static const i2s_pin_config_t i2sPinConfigRx;
    static const i2s_config_t i2sConfigTx;
    static const i2s_pin_config_t i2sPinConfigTx;
};

#endif // AUDIO_H

###########################################

############# include\config.h #############

#ifndef CONFIG_H
#define CONFIG_H

#include "U8g2lib.h"

// WiFi credentials
#define WIFI_SSID "Xperia 1 II"
#define WIFI_PASSWORD "12345678"

// WebSocket server details
#define WS_SERVER "192.168.8.35"
#define WS_PORT 8765

// L298N motor driver configuration
#define MOTOR_PIN1 8
#define MOTOR_PIN2 9
#define MOTOR_ENABLE 10

// PIR sensor configuration
#define PIR_PIN 21

// Break beam sensor configuration
#define BREAK_BEAM_PIN 2

// LED strip configuration
#define LED_STRIP_PIN 38


// I2S configuration
#define I2S_PIN_BCLK 13
#define I2S_PIN_DATA 21
#define I2S_PIN_LRCK 14

#define I2S_PIN_INMP441_SD 39
#define I2S_PIN_INMP441_WS 41
#define I2S_PIN_INMP441_SCK 40

// Audio settings
#define SAMPLE_RATE 44100
#define BITS_PER_SAMPLE 16
#define CHANNELS 1
#define DMA_BUF_COUNT 16
#define DMA_BUF_LEN 1024

// Buffer sizes
#define I2S_BUFFER_SIZE (1024 * 8)

// Fingerprint sensor configuration
#define FINGERPRINT_TX 17
#define FINGERPRINT_RX 18

// OLED I2C address
#define SDA_PIN 8
#define SCL_PIN 18
#define I2C_ADDRESS 0x3C

// Define images
static const unsigned char image_notification_bell_bits[]
        U8X8_PROGMEM = {0x88, 0x11, 0xc6, 0x63, 0x22, 0x44, 0x31, 0x88, 0x11, 0x88, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10,
                        0x08,
                        0x10, 0x04, 0x20, 0x04, 0x20, 0x02, 0x40, 0xff, 0xff, 0x60, 0x06, 0xc0, 0x03, 0x00, 0x00};
static const unsigned char image_device_lock_bits[]
        U8X8_PROGMEM = {0xf0, 0x01, 0x08, 0x02, 0xe4, 0x04, 0x12, 0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0xfe, 0x0f, 0x03, 0x18,
                        0xe5,
                        0x14, 0x11, 0x11, 0x11, 0x11, 0xa1, 0x10, 0xa1, 0x10, 0x45, 0x14, 0x03, 0x18, 0xfe, 0x0f};
static const unsigned char image_microphone_bits[]
        U8X8_PROGMEM = {0xc0, 0x01, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03, 0xa0, 0x02, 0xe0, 0x03,
                        0xe8,
                        0x0b, 0xc8, 0x09, 0x10, 0x04, 0xe0, 0x03, 0x80, 0x00, 0x80, 0x00, 0xe0, 0x03, 0x00, 0x00};
static const unsigned char image_volume_loud_bits[]
        U8X8_PROGMEM = {0x80, 0x83, 0x00, 0x40, 0x02, 0x01, 0x20, 0x22, 0x02, 0x10, 0x42, 0x04, 0x0f, 0x8a, 0x04, 0x01,
                        0x92,
                        0x08, 0x01, 0x22, 0x09, 0x01, 0x22, 0x09, 0x01, 0x22, 0x09, 0x01, 0x92, 0x08, 0x0f, 0x8a, 0x04,
                        0x10,
                        0x42, 0x04, 0x20, 0x22, 0x02, 0x40, 0x02, 0x01, 0x80, 0x83, 0x00, 0x00, 0x00, 0x00};


#endif // CONFIG_H

############################################

############# include\esp_now_manager.h #############

#ifndef ESP_NOW_MANAGER_H
#define ESP_NOW_MANAGER_H

#include <Arduino.h>
#include <esp_now.h>
#include "events.h"

#define ESPNOW_CHANNEL 1

class ESPNow {
public:
    void begin(EventDispatcher &dispatcher);

    static void sendCommand(const char *command);

private:
    static void onDataReceived(const uint8_t *mac, const uint8_t *data, int len);

    static void onDataSent(const uint8_t *mac_addr, esp_now_send_status_t status);

    static EventDispatcher *eventDispatcher;
    static esp_now_peer_info_t peerInfo;
    static const uint8_t broadcastAddress[];
};

#endif //ESP_NOW_MANAGER_H


#####################################################

############# include\events.h #############

#ifndef EVENTS_H
#define EVENTS_H

#include <functional>
#include <vector>
#include <bitset>
#include <cstdint>
#include <string>

// Increase or decrease this value based on the number of events you need
constexpr size_t MAX_EVENTS = 64;

using EventType = uint8_t;

struct Event {
    EventType type;
    std::string data;
    size_t dataLength;

    Event(EventType t, const std::string &d = "", size_t s = 0)
            : type(t), data(d), dataLength(s == 0 ? d.size() : s) {}
};

using EventCallback = std::function<void(const Event &)>;

class EventDispatcher {
public:
    void registerCallback(EventType type, EventCallback callback);

    void dispatchEvent(const Event &event);

    void removeCallback(EventType type);

private:
    struct CallbackEntry {
        EventType type;
        EventCallback callback;
    };

    std::vector<CallbackEntry> callbacks;
    std::bitset<MAX_EVENTS> registeredEvents;
};

// Define your event types here
enum Events : EventType {
    WS_CONNECTED = 0,
    CMD_START_RECORDING,
    CMD_STOP_RECORDING,
    CMD_START_PLAYING,
    CMD_STOP_PLAYING,
    KEYPAD_PRESS,
    FINGERPRINT_MATCHED,
    FINGERPRINT_NO_MATCH,
    AUDIO_DATA_RECEIVED,
    AUDIO_CHUNK_READ,
    ESPNOW_DATA_RECEIVED,
    MOTION_DETECTED,
    BREAK_BEAM_TRIGGERED,
    CMD_CHANGE_STATE,
    GATE_OPENED,
    GATE_CLOSED,
    LED_TURNED_ON,
    LED_TURNED_OFF,
    PASSWORD_VALIDATED,
    CMD_GRANT_ACCESS,
    CMD_DENY_ACCESS

};

#endif // EVENTS_H

############################################

############# include\event_handler.h #############

#ifndef EVENT_HANDLER_H
#define EVENT_HANDLER_H

#include "events.h"
#include "audio.h"
#include "network_manager.h"
#include "gate_control.h"
#include "led_control.h"
#include "ui.h"
#include "esp_now.h"
#include "esp_now_manager.h"

class EventHandler {
public:
    EventHandler(Audio &audio, NetworkManager &network, GateControl &gate, LEDControl &led, UI &ui, ESPNow &espNow);

    void registerCallbacks(EventDispatcher &dispatcher);

private:
    Audio &audio;
    NetworkManager &network;
    GateControl &gate;
    LEDControl &led;
    UI &ui;
    ESPNow &espNow;

    void handleRecordStart(const Event &event);

    void handleRecordStop(const Event &event);

    void handlePlaybackStart(const Event &event);

    void handlePlaybackStop(const Event &event);

    void handleWebSocketConnected(const Event &event);

    void handleAudioDataReceived(const Event &event);

    void handleAudioChunkRead(const Event &event);

    void handleFingerprintMatch(const Event &event);

    void handleFingerprintNoMatch(const Event &event);

    void handleChangeState(const Event &event);

    void handleChangeStateSuccess(const Event &event);

    void handleResidentAuthorized(const Event &event);

    void handleGrantAccess(const Event &event);

    void handleDenyAccess(const Event &event);

    void handleMotionDetected(const Event &event);
};

#endif // EVENT_HANDLER_H

###################################################

############# include\fingerprint.h #############

#ifndef FINGERPRINT_H
#define FINGERPRINT_H

#include "Adafruit_Fingerprint.h"
#include "events.h"

class FingerprintHandler {
public:
    explicit FingerprintHandler(const HardwareSerial &serial);

    void begin(EventDispatcher &dispatcher);

private:
    static void fingerprintTask(void *parameter);

    HardwareSerial mySerial;
    Adafruit_Fingerprint fingerprint;
    EventDispatcher *eventDispatcher{};
};

#endif // FINGERPRINT_H

#################################################

############# include\gate_control.h #############

#ifndef GATE_CONTROL_H
#define GATE_CONTROL_H

#include <Arduino.h>
#include "events.h"

class GateControl {
public:
    GateControl(int motorPin1, int motorPin2, int enablePin);

    void begin(EventDispatcher &dispatcher);

    void openGate();

    void closeGate();

    bool isGateMoving() const;

    static bool isGateOpen(); // Make non-const

private:
    static void gateControlTask(void *parameter);

    int _motorPin1;
    int _motorPin2;
    int _enablePin;

    unsigned long _movementStartTime = 0;
    bool _isMoving = false;
    static volatile bool _isGateOpen;

    static EventDispatcher *eventDispatcher;

    // Use a mutex to protect _isGateOpen
    static SemaphoreHandle_t _gateStateMutex;
};

#endif // GATE_CONTROL_H


##################################################

############# include\led_control.h #############

#ifndef LED_CONTROL_H
#define LED_CONTROL_H

#include <Arduino.h>
#include "events.h"

class LEDControl {
public:
    explicit LEDControl(int pin);

    void begin(EventDispatcher &dispatcher);

    void turnOn();

    void turnOff();

private:
    int _pin;
    static EventDispatcher *eventDispatcher;
};

#endif // LED_CONTROL_H

#################################################

############# include\logger.h #############

#ifndef LOGGER_H
#define LOGGER_H

#include <Arduino.h>
#include <cstdarg>

enum LogLevel {
    LOG_NONE = 0,   // No logging
    LOG_ERROR,
    LOG_WARN,
    LOG_INFO,
    LOG_DEBUG
};

extern LogLevel currentLogLevel; // Declare as extern

extern void logger(LogLevel level, const char *tag, const char *format, ...); // Declare as extern

// Macros for convenience (similar to esp_log)
#define LOG_E(tag, format, ...) logger(LOG_ERROR, tag, format, ##__VA_ARGS__)
#define LOG_W(tag, format, ...) logger(LOG_WARN,  tag, format, ##__VA_ARGS__)
#define LOG_I(tag, format, ...) logger(LOG_INFO,  tag, format, ##__VA_ARGS__)
#define LOG_D(tag, format, ...) logger(LOG_DEBUG, tag, format, ##__VA_ARGS__)

#endif // LOGGER_H


############################################

############# include\network_manager.h #############

#ifndef WIFI_H
#define WIFI_H

#include "WebSocketsClient.h"
#include "events.h"
#include "ArduinoJson.h"

class NetworkManager {
public:
    void begin(EventDispatcher &dispatcher);

    static void loop();

    static void sendInitMessage();

    static void sendAudioChunk(const uint8_t *data, size_t len);

    static void sendEvent(const char *eventType, const JsonObject &data);

private:
    static void webSocketEvent(WStype_t type, uint8_t *payload, size_t length);

    static EventDispatcher *eventDispatcher;
    static WebSocketsClient webSocket;

};

#endif // WIFI_H

#####################################################

############# include\sensors.h #############

#ifndef SENSORS_H
#define SENSORS_H

#include <Arduino.h>
#include "events.h"

class PIRSensor {
public:
    explicit PIRSensor(int pin);
    void begin(EventDispatcher &dispatcher);

private:
    static void pirTask(void *parameter);
    int _pin;
    unsigned long _lastDebounceTime;
    int _lastState;
    int _state;
    static EventDispatcher *eventDispatcher;
};

class BreakBeamSensor {
public:
    explicit BreakBeamSensor(int pin);
    void begin(EventDispatcher &dispatcher);

private:
    static void breakBeamTask(void *parameter);
    int _pin;
    unsigned long _lastDebounceTime;
    int _lastState;
    int _state;
    static EventDispatcher *eventDispatcher;
};

#endif // SENSORS_H

#############################################

############# include\ui.h #############

#ifndef UI_H
#define UI_H

#include <U8g2lib.h>
#include <Keypad.h>
#include "events.h"

class UI {
public:
    UI();

    void begin(EventDispatcher &dispatcher);

    void update();

    void displayAccessGranted();

    void displayAccessDenied();

private:
    static void uiTask(void *parameter);

    void displayMenu();

    void handleKeyPress(char key);

    void displayPasswordResult(bool correct);

    void displayRecordingMessage();

    void displayPlayingMessage();

    void displayFingerprintNoMatch();

    void displayMotionDetected();

    void displayFingerprintMatched();


    U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2;
    Keypad keypad;

    static const char *menuItems[];
    static const int menuItemCount;
    int currentMenuItem;
    bool notificationDisplayed;
    bool enteringPassword;
    bool passwordCorrect;
    bool passwordChecked;
    bool recordingAudio;
    bool playingAudio;
    char enteredPassword[5]{};
    int passwordIndex;
    static const char correctPassword[];

    static EventDispatcher *eventDispatcher;

};

#endif // UI_H

########################################

############# src\audio.cpp #############

#include "audio.h"
#include "config.h"
#include "network_manager.h"
#include <esp_log.h>

static const char *TAG = "AUDIO";

const i2s_config_t Audio::i2sConfigRx = {
        .mode = (i2s_mode_t) (I2S_MODE_MASTER | I2S_MODE_RX),
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = (i2s_bits_per_sample_t) BITS_PER_SAMPLE,
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = (i2s_comm_format_t) (I2S_COMM_FORMAT_STAND_I2S),
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = DMA_BUF_COUNT,
        .dma_buf_len = DMA_BUF_LEN,
        .use_apll = false,
        .tx_desc_auto_clear = true,
        .fixed_mclk = 0
};

const i2s_pin_config_t Audio::i2sPinConfigRx = {
        .bck_io_num = I2S_PIN_INMP441_SCK,
        .ws_io_num = I2S_PIN_INMP441_WS,
        .data_out_num = I2S_PIN_NO_CHANGE,
        .data_in_num = I2S_PIN_INMP441_SD
};

const i2s_config_t Audio::i2sConfigTx = {
        .mode = (i2s_mode_t) (I2S_MODE_MASTER | I2S_MODE_TX),
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = (i2s_bits_per_sample_t) BITS_PER_SAMPLE,
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = (i2s_comm_format_t) (I2S_COMM_FORMAT_STAND_I2S),
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = DMA_BUF_COUNT,
        .dma_buf_len = DMA_BUF_LEN,
        .use_apll = false
};

const i2s_pin_config_t Audio::i2sPinConfigTx = {
        .bck_io_num = I2S_PIN_BCLK,
        .ws_io_num = I2S_PIN_LRCK,
        .data_out_num = I2S_PIN_DATA,
        .data_in_num = I2S_PIN_NO_CHANGE
};

SemaphoreHandle_t Audio::i2sBufferMutex = nullptr;
uint8_t *Audio::i2sBuffer = nullptr;
size_t Audio::i2sBufferSize = I2S_BUFFER_SIZE;
volatile size_t Audio::i2sBufferHead = 0;
volatile size_t Audio::i2sBufferTail = 0;
TaskHandle_t Audio::i2sReaderTaskHandle = nullptr;
TaskHandle_t Audio::i2sWriterTaskHandle = nullptr;

void Audio::begin() {
    i2sBufferMutex = xSemaphoreCreateMutex();

    // Allocate memory for the I2S buffer dynamically
    i2sBuffer = (uint8_t *) malloc(i2sBufferSize * sizeof(uint8_t));

    if (i2sBuffer == nullptr) {
        ESP_LOGE(TAG, "Error allocating memory for I2S buffer!");
    }

    // Initialize I2S RX
    if (i2s_driver_install(I2S_NUM_1, &i2sConfigRx, 0, nullptr) != ESP_OK) {
        ESP_LOGE(TAG, "Error installing I2S RX driver!");
    }

    i2s_set_pin(I2S_NUM_1, &i2sPinConfigRx);
    i2s_zero_dma_buffer(I2S_NUM_1);

    // Initialize I2S TX
    if (i2s_driver_install(I2S_NUM_0, &i2sConfigTx, 0, nullptr) != ESP_OK) {
        ESP_LOGE(TAG, "Error installing I2S TX driver!");
    }
    i2s_set_pin(I2S_NUM_0, &i2sPinConfigTx);
    i2s_zero_dma_buffer(I2S_NUM_0);

    xTaskCreatePinnedToCore(i2sReaderTask, "I2S Reader Task", 8192, nullptr, 2, &i2sReaderTaskHandle, 1);
    xTaskCreatePinnedToCore(i2sWriterTask, "I2S Writer Task", 8192, nullptr, 3, &i2sWriterTaskHandle, 1);

    vTaskSuspend(i2sReaderTaskHandle); // Initially suspend the reader task
    vTaskSuspend(i2sWriterTaskHandle); // Initially suspend the writer task
}

void Audio::startRecording() {
    vTaskResume(i2sReaderTaskHandle);
    ESP_LOGI(TAG, "Recording started");
}

void Audio::stopRecording() {
    vTaskSuspend(i2sReaderTaskHandle);
    ESP_LOGI(TAG, "Recording stopped");
}

void Audio::startPlayback() {
    vTaskResume(i2sWriterTaskHandle);
    ESP_LOGI(TAG, "Playback started");
}

void Audio::stopPlayback() {
    vTaskSuspend(i2sWriterTaskHandle);
    ESP_LOGI(TAG, "Playback stopped");

    // Clear the I2S DMA buffer
    i2s_zero_dma_buffer(I2S_NUM_0);

    // Clear the buffer when playback stops
    if (xSemaphoreTake(i2sBufferMutex, portMAX_DELAY) == pdTRUE) {
        i2sBufferHead = 0;
        i2sBufferTail = 0;
        xSemaphoreGive(i2sBufferMutex);
    }
}

void Audio::addDataToBuffer(const uint8_t *data, size_t length) {
    if (xSemaphoreTake(i2sBufferMutex, portMAX_DELAY) == pdTRUE) {
        for (size_t i = 0; i < length; i++) {
            i2sBuffer[i2sBufferHead] = data[i];
            i2sBufferHead = (i2sBufferHead + 1) % I2S_BUFFER_SIZE;
            if (i2sBufferHead == i2sBufferTail) // Buffer overflow, discard oldest data
            {
                i2sBufferTail = (i2sBufferTail + 1) % I2S_BUFFER_SIZE;
            }
        }
        xSemaphoreGive(i2sBufferMutex);
    }
}

[[noreturn]] void Audio::i2sReaderTask(void *parameter) {
    size_t bytesRead = 0;

    // Dynamically allocate i2SMicBuffer
    auto *i2SMicBuffer = new uint8_t[DMA_BUF_LEN * 2];
    auto *prependedBuffer = new uint8_t[DMA_BUF_LEN * 2 + 6];

    while (true) {
        i2s_read(I2S_NUM_1, i2SMicBuffer, DMA_BUF_LEN * 2, &bytesRead, portMAX_DELAY); // Read from Microphone
        if (bytesRead > 0) {
            memcpy(prependedBuffer, "AUDIO:", 6);
            memcpy(prependedBuffer + 6, i2SMicBuffer, bytesRead);

            NetworkManager::sendAudioChunk(prependedBuffer, bytesRead + 6);


//            Event event = {AUDIO_CHUNK_READ, std::string(reinterpret_cast<char *>(prependedBuffer)),
//                           bytesRead + 6};
//            eventDispatcher->dispatchEvent(event);
        }

    }

    // Free allocated memory
    delete[] i2SMicBuffer;
    delete[] prependedBuffer;
}

[[noreturn]] void Audio::i2sWriterTask(void *parameter) {
    size_t bytesWritten = 0;
    for (;;) {
        if (xSemaphoreTake(i2sBufferMutex, portMAX_DELAY) == pdTRUE) {
            if (i2sBufferTail != i2sBufferHead) {
                size_t bytesToWrite = (i2sBufferTail < i2sBufferHead) ? (i2sBufferHead - i2sBufferTail) : (
                        I2S_BUFFER_SIZE - i2sBufferTail);
                i2s_write(I2S_NUM_0, &i2sBuffer[i2sBufferTail], bytesToWrite, &bytesWritten, portMAX_DELAY);
                i2sBufferTail = (i2sBufferTail + bytesWritten) % I2S_BUFFER_SIZE;
            }
            xSemaphoreGive(i2sBufferMutex);
        }
        vTaskDelay(10);
    }
}

#########################################

############# src\esp_now_manager.cpp #############

#include "esp_now_manager.h"
#include "logger.h"

static const char *TAG = "ESPNow";

EventDispatcher *ESPNow::eventDispatcher = nullptr;
esp_now_peer_info_t ESPNow::peerInfo;

const uint8_t ESPNow::broadcastAddress[] = {0x34, 0x98, 0x7A, 0xB6, 0x8E, 0x88};

void ESPNow::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    if (esp_now_init() != ESP_OK) {
        LOG_E(TAG, "Error initializing ESP-NOW");
        return;
    }

    esp_now_register_recv_cb(onDataReceived);
    esp_now_register_send_cb(onDataSent);

    memcpy(peerInfo.peer_addr, broadcastAddress, 6);
    peerInfo.channel = ESPNOW_CHANNEL;
    peerInfo.encrypt = false;

    if (esp_now_add_peer(&peerInfo) != ESP_OK) {
        LOG_E(TAG, "Failed to add peer");
        return;
    }

    LOG_I(TAG, "ESP-NOW initialized successfully");
}

void ESPNow::sendCommand(const char *command) {
    esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) command, strlen(command));
    if (result != ESP_OK) {
        LOG_E(TAG, "Failed to send data: %d", result);
    } else {
        LOG_I(TAG, "Command sent successfully: %s", command);
    }
}

void ESPNow::onDataReceived(const uint8_t *mac, const uint8_t *data, int len) {
    char *receivedData = (char *) malloc(len + 1);
    memcpy(receivedData, data, len);
    receivedData[len] = '\0';

    LOG_I(TAG, "Received data: %s", receivedData);
    eventDispatcher->dispatchEvent({ESPNOW_DATA_RECEIVED, std::string(receivedData), static_cast<size_t>(len)});

    free(receivedData);
}

void ESPNow::onDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
    LOG_I(TAG, "Last Packet Send Status: %s", status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}

###################################################

############# src\events.cpp #############

#include "events.h"
#include "logger.h"

static const char *TAG = "EventDispatcher";

void EventDispatcher::registerCallback(EventType type, EventCallback callback) {
    if (type >= MAX_EVENTS) {
        LOG_E(TAG, "Event type out of range: %d", type);
        return;
    }

    callbacks.push_back({type, std::move(callback)});
    registeredEvents.set(type);
    LOG_D(TAG, "Registered callback for event type: %d", type);
}

void EventDispatcher::dispatchEvent(const Event &event) {
    if (event.type >= MAX_EVENTS) {
        LOG_E(TAG, "Invalid event type: %d", event.type);
        return;
    }

    if (!registeredEvents.test(event.type)) {
        LOG_W(TAG, "No callbacks registered for event type: %d", event.type);
        return;
    }

    LOG_D(TAG, "Dispatching event: %d, data size: %zu", event.type, event.dataLength);
    for (const auto &entry: callbacks) {
        if (entry.type == event.type) {
            entry.callback(event);
        }
    }
}

void EventDispatcher::removeCallback(EventType type) {
    if (type >= MAX_EVENTS) {
        LOG_E(TAG, "Event type out of range: %d", type);
        return;
    }

    callbacks.erase(
            std::remove_if(callbacks.begin(), callbacks.end(),
                           [type](const CallbackEntry &entry) { return entry.type == type; }),
            callbacks.end()
    );

    if (callbacks.end() == std::find_if(callbacks.begin(), callbacks.end(),
                                        [type](const CallbackEntry &entry) { return entry.type == type; })) {
        registeredEvents.reset(type);
    }

    LOG_D(TAG, "Removed callback(s) for event type: %d", type);
}

##########################################

############# src\event_handler.cpp #############

#include "event_handler.h"
#include "logger.h"
#include "esp_now_manager.h"
#include <ArduinoJson.h>

static const char *TAG = "EventHandler";

EventHandler::EventHandler(Audio &audio, NetworkManager &network, GateControl &gate, LEDControl &led, UI &ui, ESPNow &espNow)
        : audio(audio), network(network), gate(gate), led(led), ui(ui), espNow(espNow) {}

void EventHandler::registerCallbacks(EventDispatcher &dispatcher) {
    dispatcher.registerCallback(CMD_START_RECORDING, [this](const Event &e) { handleRecordStart(e); });
    dispatcher.registerCallback(CMD_STOP_RECORDING, [this](const Event &e) { handleRecordStop(e); });
    dispatcher.registerCallback(CMD_START_PLAYING, [this](const Event &e) { handlePlaybackStart(e); });
    dispatcher.registerCallback(CMD_STOP_PLAYING, [this](const Event &e) { handlePlaybackStop(e); });
    dispatcher.registerCallback(WS_CONNECTED, [this](const Event &e) { handleWebSocketConnected(e); });
    dispatcher.registerCallback(AUDIO_DATA_RECEIVED, [this](const Event &e) { handleAudioDataReceived(e); });
    dispatcher.registerCallback(AUDIO_CHUNK_READ, [this](const Event &e) { handleAudioChunkRead(e); });
    dispatcher.registerCallback(FINGERPRINT_NO_MATCH, [this](const Event &e) { handleFingerprintNoMatch(e); });
    dispatcher.registerCallback(CMD_CHANGE_STATE, [this](const Event &e) { handleChangeState(e); });
    dispatcher.registerCallback(GATE_OPENED, [this](const Event &e) { handleChangeStateSuccess(e); });
    dispatcher.registerCallback(GATE_CLOSED, [this](const Event &e) { handleChangeStateSuccess(e); });
    dispatcher.registerCallback(LED_TURNED_ON, [this](const Event &e) { handleChangeStateSuccess(e); });
    dispatcher.registerCallback(LED_TURNED_OFF, [this](const Event &e) { handleChangeStateSuccess(e); });
    dispatcher.registerCallback(FINGERPRINT_MATCHED, [this](const Event &e) { handleResidentAuthorized(e); });
    dispatcher.registerCallback(PASSWORD_VALIDATED, [this](const Event &e) { handleResidentAuthorized(e); });
    dispatcher.registerCallback(CMD_GRANT_ACCESS, [this](const Event &e) { handleGrantAccess(e); });
    dispatcher.registerCallback(CMD_DENY_ACCESS, [this](const Event &e) { handleDenyAccess(e); });
    dispatcher.registerCallback(MOTION_DETECTED, [this](const Event &e) { handleMotionDetected(e); });
}


void EventHandler::handleRecordStart(const Event &event) {
    audio.startRecording();
    LOG_I(TAG, "Recording started");
}

void EventHandler::handleRecordStop(const Event &event) {
    audio.stopRecording();
    LOG_I(TAG, "Recording stopped");
}

void EventHandler::handlePlaybackStart(const Event &event) {
    audio.startPlayback();
    LOG_I(TAG, "Playback started");
}

void EventHandler::handlePlaybackStop(const Event &event) {
    audio.stopPlayback();
    LOG_I(TAG, "Playback stopped");
}

void EventHandler::handleWebSocketConnected(const Event &event) {
    network.sendInitMessage();
}

void EventHandler::handleAudioDataReceived(const Event &event) {
    audio.addDataToBuffer(reinterpret_cast<const uint8_t *>(event.data.data()), event.dataLength);
    LOG_D(TAG, "Audio data received and added to buffer");
}

void EventHandler::handleAudioChunkRead(const Event &event) {
    network.sendAudioChunk(reinterpret_cast<const uint8_t *>(event.data.data()), event.dataLength);
    LOG_D(TAG, "Audio chunk read and sent");
}

void EventHandler::handleFingerprintMatch(const Event &event) {
    LOG_I(TAG, "Fingerprint match found!");
    gate.openGate();
    led.turnOn();
}

void EventHandler::handleFingerprintNoMatch(const Event &event) {
    LOG_I(TAG, "Fingerprint no match found!");
    led.turnOff();
}

void EventHandler::handleChangeState(const Event &event) {
    StaticJsonDocument<256> doc;
    deserializeJson(doc, event.data);

    const char *device = doc["device"];
    const char *state = doc["state"];

    if (strcmp(device, "gate") == 0) {
        strcmp(state, "open") == 0 ? gate.openGate() : gate.closeGate();
    } else if (strcmp(device, "light") == 0) {
        strcmp(state, "on") == 0 ? led.turnOn() : led.turnOff();
    } else {
        LOG_W(TAG, "Unknown device: %s", device);
    }
}

void EventHandler::handleChangeStateSuccess(const Event &event) {
    StaticJsonDocument<256> data;

    if (event.type == GATE_OPENED || event.type == GATE_CLOSED) {
        data["device"] = "gate";
        data["state"] = event.type == GATE_OPENED ? "open" : "close";
    } else if (event.type == LED_TURNED_ON || event.type == LED_TURNED_OFF) {
        data["device"] = "light";
        data["state"] = event.type == LED_TURNED_ON ? "on" : "off";
    }

    network.sendEvent("change_state", data.as<JsonObject>());
}

void EventHandler::handleResidentAuthorized(const Event &event) {
    gate.openGate();
}

void EventHandler::handleGrantAccess(const Event &event) {
    gate.openGate();
    ui.displayAccessGranted();
}

void EventHandler::handleDenyAccess(const Event &event) {
    ui.displayAccessDenied();
}

void EventHandler::handleMotionDetected(const Event &event) {
    espNow.sendCommand("capture_image");
    network.sendEvent("motion_detected", JsonObject());
}


#################################################

############# src\fingerprint.cpp #############

#include "fingerprint.h"
#include "config.h"
#include "logger.h"

static const char *TAG = "FINGERPRINT";

FingerprintHandler::FingerprintHandler(const HardwareSerial &serial) : mySerial(serial), fingerprint(&mySerial) {
    mySerial.begin(57600, SERIAL_8N1, FINGERPRINT_RX, FINGERPRINT_TX);
    fingerprint.begin(57600);
}

void FingerprintHandler::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    if (fingerprint.verifyPassword()) {
        LOG_I(TAG, "Found fingerprint sensor!");
        fingerprint.getTemplateCount();
        if (fingerprint.templateCount == 0) {
            LOG_E(TAG, "No fingerprint templates found. Please enroll a fingerprint first.");
        } else {
            LOG_I(TAG, "Fingerprint templates found: %d", fingerprint.templateCount);
        }
    } else {
        LOG_E(TAG, "Did not find fingerprint sensor :(");
    }

    xTaskCreate(fingerprintTask, "Fingerprint Task", 4096, this, 1, nullptr);
}

void FingerprintHandler::fingerprintTask(void *parameter) {
    auto *handler = static_cast<FingerprintHandler *>(parameter);

    while (true) {
        uint8_t p = handler->fingerprint.getImage();
        if (p == FINGERPRINT_OK) {
            LOG_I(TAG, "Image taken");
            p = handler->fingerprint.image2Tz();
            if (p == FINGERPRINT_OK) {
                LOG_I(TAG, "Image converted to template");
                p = handler->fingerprint.fingerFastSearch();
                if (p == FINGERPRINT_OK) {
                    LOG_I(TAG, "Finger found!");
                    handler->eventDispatcher->dispatchEvent({FINGERPRINT_MATCHED, ""});
                } else if (p == FINGERPRINT_NOTFOUND) {
                    LOG_I(TAG, "No match found");
                    handler->eventDispatcher->dispatchEvent({FINGERPRINT_NO_MATCH, ""});
                } else {
                    LOG_E(TAG, "Finger search error: %d", p);
                }
            } else {
                continue;
            }
        } else {
            continue;
        }
        vTaskDelay(1000);
    }
}






###############################################

############# src\gate_control.cpp #############

#include "gate_control.h"
#include "logger.h"

static const char *TAG = "GATE_CONTROL";

EventDispatcher *GateControl::eventDispatcher = nullptr;
volatile bool GateControl::_isGateOpen = false;
SemaphoreHandle_t GateControl::_gateStateMutex = xSemaphoreCreateMutex(); // Initialize the mutex

GateControl::GateControl(int motorPin1, int motorPin2, int enablePin)
        : _motorPin1(motorPin1), _motorPin2(motorPin2), _enablePin(enablePin) {}

void GateControl::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    pinMode(_motorPin1, OUTPUT);
    pinMode(_motorPin2, OUTPUT);
    pinMode(_enablePin, OUTPUT);

    xTaskCreate(gateControlTask, "Gate Control Task", 4096, this, 1, nullptr);

    LOG_I(TAG, "Gate control initialized");
}

void GateControl::openGate() {
    if (xSemaphoreTake(_gateStateMutex, portMAX_DELAY) == pdTRUE) {
        if (!_isGateOpen && !_isMoving) { // Check if gate is closed and not moving
            digitalWrite(_motorPin1, HIGH);
            digitalWrite(_motorPin2, LOW);
            digitalWrite(_enablePin, HIGH);
            _movementStartTime = millis();
            _isMoving = true;
            LOG_I(TAG, "Gate opening started...");
        } else {
            LOG_I(TAG, "Gate is already open or in motion.");
        }
        xSemaphoreGive(_gateStateMutex);
    }
}

void GateControl::closeGate() {
    if (xSemaphoreTake(_gateStateMutex, portMAX_DELAY) == pdTRUE) {
        if (_isGateOpen && !_isMoving) { // Check if gate is open and not moving
            digitalWrite(_motorPin1, LOW);
            digitalWrite(_motorPin2, HIGH);
            digitalWrite(_enablePin, HIGH);
            _movementStartTime = millis();
            _isMoving = true;
            LOG_I(TAG, "Gate closing started...");
        } else {
            LOG_I(TAG, "Gate is already closed or in motion.");
        }
        xSemaphoreGive(_gateStateMutex);
    }
}

bool GateControl::isGateMoving() const {
    return _isMoving;
}

// Make isGateOpen() non-const and protect with mutex
bool GateControl::isGateOpen() {
    if (xSemaphoreTake(_gateStateMutex, portMAX_DELAY) == pdTRUE) {
        bool gateState = _isGateOpen;
        xSemaphoreGive(_gateStateMutex);
        return gateState;
    } else {
        // Handle mutex failure (e.g., return a default value)
        return false;
    }
}

void GateControl::gateControlTask(void *parameter) {
    auto *gateControl = static_cast<GateControl *>(parameter);

    while (true) {
        if (gateControl->isGateMoving() && millis() - gateControl->_movementStartTime > 7000) {
            digitalWrite(gateControl->_enablePin, LOW);
            gateControl->_isMoving = false;

            // Update _isGateOpen within the mutex
            if (xSemaphoreTake(_gateStateMutex, portMAX_DELAY) == pdTRUE) {
                _isGateOpen = !_isGateOpen; // Toggle the state
                xSemaphoreGive(_gateStateMutex);
            }

            // Dispatch events after updating _isGateOpen
            if (_isGateOpen) {
                eventDispatcher->dispatchEvent({GATE_OPENED, ""});
            } else {
                eventDispatcher->dispatchEvent({GATE_CLOSED, ""});
            }
        }
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}


################################################

############# src\led_control.cpp #############

#include "led_control.h"
#include "logger.h"

static const char *TAG = "LED_CONTROL";

EventDispatcher *LEDControl::eventDispatcher = nullptr;

LEDControl::LEDControl(int pin) : _pin(pin) {}

void LEDControl::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    pinMode(_pin, OUTPUT);
    digitalWrite(_pin, LOW);
    LOG_I(TAG, "LED control initialized");
}

void LEDControl::turnOn() {
//    digitalWrite(_pin, HIGH);
    LOG_I(TAG, "LED turned on");
    eventDispatcher->dispatchEvent({LED_TURNED_ON, ""});
}

void LEDControl::turnOff() {
    digitalWrite(_pin, LOW);
    LOG_I(TAG, "LED turned off");
    eventDispatcher->dispatchEvent({LED_TURNED_OFF, ""});
}

###############################################

############# src\main.cpp #############

#include <Arduino.h>
#include "events.h"
#include "audio.h"
#include "network_manager.h"
#include "ui.h"
#include "fingerprint.h"
#include "logger.h"
#include "esp_now_manager.h"
#include "gate_control.h"
#include "sensors.h"
#include "led_control.h"
#include "config.h"
#include "event_handler.h"

#define LOG_BUFFER_SIZE 128

// Define currentLogLevel
LogLevel currentLogLevel = LOG_INFO;

// Define the logger function
void logger(LogLevel level, const char *tag, const char *format, ...) {
    if (level > currentLogLevel) return; // Skip if below current log level

    char message[LOG_BUFFER_SIZE];
    va_list args;
    va_start(args, format);
    vsnprintf(message, LOG_BUFFER_SIZE, format, args);
    va_end(args);

    // Formatted output
    Serial.printf("[%s][%s]: %s\n",
                  level == LOG_ERROR ? "ERROR" : (
                          level == LOG_WARN ? "WARN" : (
                                  level == LOG_INFO ? "INFO" : (
                                          level == LOG_DEBUG ? "DEBUG" : "???"))),
                  tag, message);
}

static const char *TAG = "MAIN";

void checkPSRAM() {
    if (psramFound()) {
        LOG_I(TAG, "PSRAM is available");
    } else {
        LOG_E(TAG, "PSRAM is not available or not initialized");
    }
}

EventDispatcher eventDispatcher;
NetworkManager wifiHandler;
UI ui;
HardwareSerial fingerprintSerial(1);
FingerprintHandler fingerprintHandler(fingerprintSerial);
GateControl gateControl(MOTOR_PIN1, MOTOR_PIN2, MOTOR_ENABLE);
PIRSensor pirSensor(PIR_PIN);
BreakBeamSensor breakBeamSensor(BREAK_BEAM_PIN);
LEDControl ledControl(LED_STRIP_PIN);
Audio audio;
ESPNow espNow;
EventHandler eventHandler(audio, wifiHandler, gateControl, ledControl, ui, espNow);

void setup() {
    eventHandler.registerCallbacks(eventDispatcher);
    Serial.begin(115200);
    checkPSRAM();

    wifiHandler.begin(eventDispatcher);
    ui.begin(eventDispatcher);
    audio.begin();
    fingerprintHandler.begin(eventDispatcher);
    gateControl.begin(eventDispatcher);
    pirSensor.begin(eventDispatcher);
    breakBeamSensor.begin(eventDispatcher);
    ledControl.begin(eventDispatcher);
    espNow.begin(eventDispatcher);

    LOG_I("MAIN", "System initialization complete");
}

void loop() {
    // Not needed, all tasks are handled by the FreeRTOS scheduler.
}


########################################

############# src\network_manager.cpp #############

#include "network_manager.h"
#include "config.h"
#include "audio.h"
#include <ArduinoJson.h>
#include <WiFi.h>
#include "logger.h"

static const char *TAG = "NetworkManager";

EventDispatcher *NetworkManager::eventDispatcher = nullptr;
WebSocketsClient NetworkManager::webSocket;

void NetworkManager::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;

    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    int connectionAttempts = 0;
    while (WiFiClass::status() != WL_CONNECTED && connectionAttempts < 10) {
        delay(500);
        connectionAttempts++;
    }

    if (WiFiClass::status() == WL_CONNECTED) {
        LOG_I(TAG, "Connected to WiFi network");
    } else {
        LOG_E(TAG, "Failed to connect to WiFi network");
        return;
    }

    webSocket.begin(WS_SERVER, WS_PORT);
    webSocket.onEvent(webSocketEvent);

    xTaskCreate([](void *param) {
        while (true) {
            NetworkManager::loop();
            vTaskDelay(10);
        }
    }, "WiFi Task", 8192, this, 2, nullptr);
}


void NetworkManager::loop() {
    webSocket.loop();
}

void NetworkManager::webSocketEvent(WStype_t type, uint8_t *payload, size_t length) {
    StaticJsonDocument<200> doc;

    switch (type) {
        case WStype_DISCONNECTED:
            LOG_I(TAG, "WebSocket disconnected");
            break;
        case WStype_CONNECTED:
            LOG_I(TAG, "WebSocket connected");
            eventDispatcher->dispatchEvent({WS_CONNECTED, ""});
            break;
        case WStype_TEXT: {
            DeserializationError error = deserializeJson(doc, payload, length);
            if (error) {
                LOG_E(TAG, "Failed to parse JSON: %s", error.c_str());
                return;
            }

            const char *event_type = doc["event_type"];
            LOG_I(TAG, "Received event: %s", event_type);

            // Log the entire JSON payload
            String jsonString;
            serializeJson(doc, jsonString);
            LOG_I(TAG, "Received JSON: %s", jsonString.c_str());

            if (strcmp(event_type, "audio") == 0) {
                const char *action = doc["action"];

                if (strcmp(action, "start_recording") == 0) {
                    eventDispatcher->dispatchEvent({CMD_START_RECORDING, ""});
                } else if (strcmp(action, "stop_recording") == 0) {
                    eventDispatcher->dispatchEvent({CMD_STOP_RECORDING, ""});
                } else if (strcmp(action, "start_playing") == 0) {
                    eventDispatcher->dispatchEvent({CMD_START_PLAYING, ""});
                } else if (strcmp(action, "stop_playing") == 0) {
                    eventDispatcher->dispatchEvent({CMD_STOP_PLAYING, ""});
                }
            } else if (strcmp(event_type, "change_state") == 0) {
                JsonObject data = doc["data"];
                String jsonString;
                serializeJson(data, jsonString);
                eventDispatcher->dispatchEvent({CMD_CHANGE_STATE, jsonString.c_str()});
            } else if (strcmp(event_type, "grant_access") == 0) {
                eventDispatcher->dispatchEvent({CMD_GRANT_ACCESS, "", 0});
            } else if (strcmp(event_type, "deny_access") == 0) {
                eventDispatcher->dispatchEvent({CMD_DENY_ACCESS, "", 0});
            }
            break;
        }
        case WStype_BIN: {
        }
            Event event = {AUDIO_DATA_RECEIVED, std::string(reinterpret_cast<char *>(payload), length), length};
            eventDispatcher->dispatchEvent(event);
            break;
    }
}

void NetworkManager::sendInitMessage() {
    LOG_I(TAG, "Sent init message");
    webSocket.sendTXT(R"({"event_type":"init","data":{"device":"esp_s3"}})");
}

void NetworkManager::sendAudioChunk(const uint8_t *data, size_t len) {
    webSocket.sendBIN(data, len);
}

void NetworkManager::sendEvent(const char *eventType, const JsonObject &data) {
    StaticJsonDocument<256> doc;
    doc["event_type"] = eventType;
    doc["data"] = data;

    char buffer[256];
    size_t length = serializeJson(doc, buffer);

    webSocket.sendTXT(buffer, length);
    LOG_I(TAG, "Sent event: %s", eventType);
}

###################################################

############# src\sensors.cpp #############

#include "sensors.h"
#include "logger.h"

static const char *TAG_PIR = "PIR_SENSOR";
static const char *TAG_BREAK_BEAM = "BREAK_BEAM_SENSOR";

// PIR Sensor Implementation
EventDispatcher *PIRSensor::eventDispatcher = nullptr;

PIRSensor::PIRSensor(int pin) : _pin(pin), _lastDebounceTime(0), _lastState(LOW), _state(LOW) {}

void PIRSensor::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    pinMode(_pin, INPUT);
    xTaskCreate(pirTask, "PIR Sensor Task", 2048, this, 1, nullptr);
    LOG_I(TAG_PIR, "PIR sensor initialized");
}

void PIRSensor::pirTask(void *parameter) {
    auto *pirSensor = static_cast<PIRSensor *>(parameter);
    const unsigned long debounceDelay = 50; // 50ms debounce time
    const unsigned long cooldownTime = 60000; // 1 minute cooldown
    unsigned long lastTriggerTime = 0;

    while (true) {
        int reading = digitalRead(pirSensor->_pin);

        if (reading != pirSensor->_lastState) {
            pirSensor->_lastDebounceTime = millis();
        }

        if ((millis() - pirSensor->_lastDebounceTime) > debounceDelay) {
            if (reading != pirSensor->_state) {
                pirSensor->_state = reading;

                if (pirSensor->_state == HIGH && (millis() - lastTriggerTime) > cooldownTime) {
                    LOG_I(TAG_PIR, "Motion detected");
                    eventDispatcher->dispatchEvent({MOTION_DETECTED, ""});
                    lastTriggerTime = millis();
                }
            }
        }

        pirSensor->_lastState = reading;
        vTaskDelay(pdMS_TO_TICKS(10)); // Check every 10ms
    }
}

// Break Beam Sensor Implementation
EventDispatcher *BreakBeamSensor::eventDispatcher = nullptr;

BreakBeamSensor::BreakBeamSensor(int pin) : _pin(pin), _lastDebounceTime(0), _lastState(HIGH), _state(HIGH) {}

void BreakBeamSensor::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    pinMode(_pin, INPUT_PULLUP);
    xTaskCreate(breakBeamTask, "Break Beam Sensor Task", 2048, this, 1, nullptr);
    LOG_I(TAG_BREAK_BEAM, "Break beam sensor initialized");
}

void BreakBeamSensor::breakBeamTask(void *parameter) {
    auto *breakBeamSensor = static_cast<BreakBeamSensor *>(parameter);
    const unsigned long debounceDelay = 50; // 50ms debounce time

    while (true) {
        int reading = digitalRead(breakBeamSensor->_pin);

        if (reading != breakBeamSensor->_lastState) {
            breakBeamSensor->_lastDebounceTime = millis();
        }

        if ((millis() - breakBeamSensor->_lastDebounceTime) > debounceDelay) {
            if (reading != breakBeamSensor->_state) {
                breakBeamSensor->_state = reading;

                if (breakBeamSensor->_state == LOW) {
                    LOG_I(TAG_BREAK_BEAM, "Break beam triggered");
                    eventDispatcher->dispatchEvent({BREAK_BEAM_TRIGGERED, ""});
                }
            }
        }

        breakBeamSensor->_lastState = reading;
        vTaskDelay(pdMS_TO_TICKS(10)); // Check every 10ms
    }
}

###########################################

############# src\ui.cpp #############

#include "ui.h"
#include "config.h"
#include "logger.h"
#include <Wire.h>

static const char *TAG = "UI";

// Define keypad size
const byte ROWS = 4;
const byte COLS = 3;

char hexaKeys[ROWS][COLS] = {
        {'1', '2', '3',},
        {'4', '5', '6',},
        {'7', '8', '9',},
        {'*', '0', '#',}
};
byte rowPins[ROWS] = {4, 5, 6, 7};
byte colPins[COLS] = {15, 16, 17};

const char *UI::menuItems[] = {"NOTIFY OWNER", "ENTER PASSWORD", "RECORD AUDIO", "PLAY RECEIVED AUDIO"};
const int UI::menuItemCount = sizeof(menuItems) / sizeof(menuItems[0]);
const char UI::correctPassword[] = "1234";

EventDispatcher *UI::eventDispatcher = nullptr;

UI::UI() : u8g2(U8G2_R0, U8X8_PIN_NONE),
           keypad(makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS),
           currentMenuItem(0),
           notificationDisplayed(false),
           enteringPassword(false),
           passwordCorrect(false),
           passwordChecked(false),
           recordingAudio(false),
           playingAudio(false),
           passwordIndex(0) {

    memset(enteredPassword, 0, sizeof(enteredPassword));
}

void UI::begin(EventDispatcher &dispatcher) {
    eventDispatcher = &dispatcher;
    Wire.begin(SDA_PIN, SCL_PIN);
    u8g2.setBusClock(400000);  // Set I2C clock speed to 400kHz
    u8g2.setI2CAddress(I2C_ADDRESS * 2);
    u8g2.begin();
    xTaskCreate(uiTask, "UI Task", 4096, this, 1, nullptr);
    LOG_I(TAG, "UI initialized");
}

void UI::uiTask(void *parameter) {
    UI *ui = static_cast<UI *>(parameter);
    while (true) {
        ui->update();
        vTaskDelay(pdMS_TO_TICKS(500)); // Update every 500ms
    }
}

void UI::update() {
    char key = keypad.getKey();
    if (key) {
        LOG_I(TAG, "Key pressed: %c", key);
        handleKeyPress(key);
    }
    displayMenu();
}

void UI::handleKeyPress(char key) {
    if (enteringPassword) {
        if (key >= '0' && key <= '9' && passwordIndex < 4) {
            enteredPassword[passwordIndex++] = key;
            enteredPassword[passwordIndex] = '\0';
        } else if (key == '*') {
            passwordIndex = 0;
            enteredPassword[0] = '\0';
        } else if (key == '#') {
            passwordCorrect = (strcmp(enteredPassword, correctPassword) == 0);
            passwordChecked = true;
            enteringPassword = false;
            displayPasswordResult(passwordCorrect);
            vTaskDelay(pdMS_TO_TICKS(2000));
            passwordChecked = false;
            passwordIndex = 0;
            enteredPassword[0] = '\0';
        }
    } else if (recordingAudio || playingAudio) {
        if (key == '1') {
            recordingAudio = false;
            playingAudio = false;
        }
    } else {
        switch (key) {
            case '2':
                currentMenuItem = (currentMenuItem - 1 + menuItemCount) % menuItemCount;
                notificationDisplayed = false;
                break;
            case '8':
                currentMenuItem = (currentMenuItem + 1) % menuItemCount;
                notificationDisplayed = false;
                break;
            case '5':
                if (currentMenuItem == 0) {
                    notificationDisplayed = true;
//                    eventDispatcher->dispatchEvent({EN_CMD_CAPTURE_IMAGE, ""});
                } else if (currentMenuItem == 1) {
                    enteringPassword = true;
                } else if (currentMenuItem == 2) {
                    recordingAudio = true;
//                    eventDispatcher->dispatchEvent({RECORD_START, ""});
                } else if (currentMenuItem == 3) {
                    playingAudio = true;
//                    eventDispatcher->dispatchEvent({PLAYBACK_START, ""});
                }
                break;
        }
    }
}

void UI::displayMenu() {
    u8g2.clearBuffer();

    if (notificationDisplayed && currentMenuItem == 0) {
        u8g2.setFont(u8g2_font_profont17_tr);
        u8g2.drawStr(15, 32, "OWNER HAS BEEN");
        u8g2.drawStr(35, 47, "NOTIFIED");
    } else if (enteringPassword && currentMenuItem == 1) {
        u8g2.setFont(u8g2_font_profont17_tr);
        u8g2.drawStr(15, 32, "ENTER PASSWORD");
        u8g2.drawStr(35, 47, enteredPassword);
    } else if (recordingAudio && currentMenuItem == 2) {
        displayRecordingMessage();
    } else if (playingAudio && currentMenuItem == 3) {
        displayPlayingMessage();
    } else {
        switch (currentMenuItem) {
            case 0:
                u8g2.setFont(u8g2_font_profont17_tr);
                u8g2.drawXBMP(7, 19, 16, 16, image_notification_bell_bits);
                u8g2.drawStr(33, 25, "NOTIFY");
                u8g2.drawStr(33, 40, "OWNER");
                u8g2.drawLine(120, 8, 120, 54);
                u8g2.drawEllipse(120, 12, 1, 3);
                break;
            case 1:
                u8g2.setFont(u8g2_font_profont17_tr);
                u8g2.drawXBMP(7, 19, 16, 16, image_device_lock_bits);
                u8g2.drawStr(33, 25, "ENTER");
                u8g2.drawStr(33, 40, "PASSWORD");
                u8g2.drawLine(120, 8, 120, 54);
                u8g2.drawEllipse(120, 21, 1, 3);
                break;
            case 2:
                u8g2.setFont(u8g2_font_profont17_tr);
                u8g2.drawXBMP(7, 19, 16, 16, image_microphone_bits);
                u8g2.drawStr(33, 25, "RECORD");
                u8g2.drawStr(33, 40, "AUDIO");
                u8g2.drawLine(120, 8, 120, 54);
                u8g2.drawEllipse(120, 34, 1, 3);
                break;
            case 3:
                u8g2.setFont(u8g2_font_profont17_tr);
                u8g2.drawXBMP(7, 19, 16, 16, image_volume_loud_bits);
                u8g2.drawStr(33, 20, "PLAY");
                u8g2.drawStr(33, 36, "RECEIVED");
                u8g2.drawLine(120, 8, 120, 54);
                u8g2.drawEllipse(120, 48, 1, 3);
                u8g2.drawStr(33, 52, "AUDIO");
                break;
        }
    }

    u8g2.sendBuffer();
}

void UI::displayPasswordResult(bool correct) {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_profont17_tr);
    if (correct) {
        u8g2.drawStr(40, 32, "PASSWORD");
        u8g2.drawStr(50, 47, "CORRECT");
        eventDispatcher->dispatchEvent({PASSWORD_VALIDATED, ""});
    } else {
        u8g2.drawStr(40, 32, "PASSWORD");
        u8g2.drawStr(50, 47, "WRONG");
    }
    u8g2.sendBuffer();
}

void UI::displayRecordingMessage() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(2, 32, "RECORDING...");
    u8g2.drawStr(2, 47, "PRESS 1 TO STOP");
    u8g2.sendBuffer();
}

void UI::displayPlayingMessage() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(2, 32, "PLAYING...");
    u8g2.drawStr(2, 47, "PRESS 1 TO STOP");
    u8g2.sendBuffer();
}

void UI::displayAccessGranted() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(40, 32, "ACCESS");
    u8g2.drawStr(50, 47, "GRANTED");
    u8g2.sendBuffer();
}

void UI::displayAccessDenied() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(40, 32, "ACCESS");
    u8g2.drawStr(50, 47, "DENIED");
    u8g2.sendBuffer();
}

void UI::displayMotionDetected() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(40, 32, "MOTION");
    u8g2.drawStr(50, 47, "DETECTED");
    u8g2.sendBuffer();
}

void UI::displayFingerprintMatched() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(40, 32, "FINGERPRINT");
    u8g2.drawStr(50, 47, "MATCHED");
    u8g2.sendBuffer();
}

void UI::displayFingerprintNoMatch() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(40, 32, "FINGERPRINT");
    u8g2.drawStr(50, 47, "NO MATCH");
    u8g2.sendBuffer();
}



######################################

